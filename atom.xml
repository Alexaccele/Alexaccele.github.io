<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>code blog</title>
  
  <subtitle>记录学习中的点滴收获</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="Alexaccele.github.io.git/"/>
  <updated>2020-04-16T08:41:48.022Z</updated>
  <id>Alexaccele.github.io.git/</id>
  
  <author>
    <name>伈伈点灯</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashMap（JDK1.8）的扩容时机与阈值的探讨</title>
    <link href="Alexaccele.github.io.git/2020/02/17/HashMap%20(JDK1.8)%E7%9A%84%E6%89%A9%E5%AE%B9%E6%97%B6%E6%9C%BA%E4%B8%8E%E9%98%88%E5%80%BC%E7%9A%84%E6%8E%A2%E8%AE%A8/"/>
    <id>Alexaccele.github.io.git/2020/02/17/HashMap (JDK1.8)的扩容时机与阈值的探讨/</id>
    <published>2020-02-17T07:51:49.000Z</published>
    <updated>2020-04-16T08:41:48.022Z</updated>
    
    <content type="html"><![CDATA[<p>最近又开始复习一些基础知识，发现网上很多关于HashMap的总结有一些问题，尤其是扩容的时机和阈值的确定仍然有一些疑问，因此果断还是自己看看源码。</p><p>本文只指出部分关于扩容的问题，其他详细分析可以参考其他文章。</p><h2 id="究竟什么时候扩容"><a href="#究竟什么时候扩容" class="headerlink" title="究竟什么时候扩容"></a>究竟什么时候扩容</h2><ul><li>当put时发现table未初始化时，进行初始化扩容</li><li>当put加入节点后，发现size（键值对数量）&gt;threshold时，进行扩容</li></ul><p>在下列源码中分别对应注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;    //初始化扩容</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();    //超过阈值扩容</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阈值是如何确定的"><a href="#阈值是如何确定的" class="headerlink" title="阈值是如何确定的"></a>阈值是如何确定的</h2><p>其实最关键的就是阈值的确定，网上大部分文章只说了阈值是 <code>load factor*current capacity</code>，这个结论是正确的，但整个过程是根据使用的构造函数而有所不同的。<br>接下来我们只分析阈值和容量的关系。<br>下面是resize的部分代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">   </span><br><span class="line">    /*** 这里省略table表的变化过程***/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="无参构造函数"><a href="#无参构造函数" class="headerlink" title="无参构造函数"></a>无参构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public HashMap() &#123;</span><br><span class="line">        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到这里的无参构造函数只初始化了负载因子为默认值0.75。<br>== 注意，此时hashmap的table,threshold都还没用初始化，即此时的容量为0，阈值也为0。==<br>而在第一次put时，检查<code>table==null</code>,进行第一次resize<br><img src="https://img-blog.csdnimg.cn/20200217152914993.png" alt="在这里插入图片描述"><br>此时在resize中会进入下面的分支<br><img src="https://img-blog.csdnimg.cn/20200217153215517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTk1MzM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>所以容量cap为默认值16，阈值threshold为 16*0.75=12。<br>而在之后的每次扩容中，容量和阈值都变为原来的两倍。<br>即两者仍然保持着0.75的比例。</p><h3 id="带参数的构造函数"><a href="#带参数的构造函数" class="headerlink" title="带参数的构造函数"></a>带参数的构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码除了参数的合法判断以外，主要设置了负载因子和阈值，而阈值由tableSizeFor()函数确定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns a power of two size for the given target capacity.</span><br><span class="line"> */</span><br><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n = cap - 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 2;</span><br><span class="line">    n |= n &gt;&gt;&gt; 4;</span><br><span class="line">    n |= n &gt;&gt;&gt; 8;</span><br><span class="line">    n |= n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到注释，阈值threshold将被设置为最接近给定参数的2^n^的值。<br>==注意，此时只设置了阈值，table还没初始化，即容量cap还为0。==</p><p>同样是在put时，首次进行扩容，而扩容的分支如下<br><img src="https://img-blog.csdnimg.cn/20200217154502207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTk1MzM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到，容量cap被设置为了刚刚计算出的阈值2^n^，而阈值被重新设置为cap*loadFactor。虽然两者仍然保持着loadFactor的比例，但是先设置了阈值，然后赋值给了容量，再根据容量和负载因子重新计算阈值。这个过程中，阈值担当了一个中间变量的角色。</p><p>而在后续的扩容过程中，容量和阈值仍然保持着负载因子的比例关系，并同时变为原来的两倍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近又开始复习一些基础知识，发现网上很多关于HashMap的总结有一些问题，尤其是扩容的时机和阈值的确定仍然有一些疑问，因此果断还是自己看看源码。&lt;/p&gt;
&lt;p&gt;本文只指出部分关于扩容的问题，其他详细分析可以参考其他文章。&lt;/p&gt;
&lt;h2 id=&quot;究竟什么时候扩容&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="集合" scheme="Alexaccele.github.io.git/categories/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="集合" scheme="Alexaccele.github.io.git/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>服务发现——基于Eureka服务器实现微服务注册</title>
    <link href="Alexaccele.github.io.git/2019/06/27/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EEureka%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/"/>
    <id>Alexaccele.github.io.git/2019/06/27/服务发现——基于Eureka服务器实现微服务注册/</id>
    <published>2019-06-27T08:41:46.000Z</published>
    <updated>2020-04-16T08:44:04.572Z</updated>
    
    <content type="html"><![CDATA[<p>在任何分布式架构中，都需要找到机器所在的物理地址，这个过程称为服务发现。</p><p>服务发现的优点：</p><ul><li>可以快速对环境中运行的服务实例数量进行水平伸缩</li><li>将服务的物理位置抽象，由于服务消费者不知道实际服务实例的物理位置，因此可以从可用服务池中添加或移除服务实例</li><li>有助于提高应用的弹性。当服务实例不可用时，可从内部可用服务列表移除该实例。</li></ul><h3 id="服务发现架构"><a href="#服务发现架构" class="headerlink" title="服务发现架构"></a>服务发现架构</h3><ol><li>微服务通过服务发现代理进行注册</li><li>通过服务发现代理来查找各个微服务实例的物理位置，通常服务消费者也会在本地缓存它请求的服务实例的物理地址</li><li>服务发现节点共享微服务实例的健康信息</li><li>微服务向服务发现代理发送心跳包，如果微服务不可用，则服务发现节点将移除对应实例IP</li></ol><p>本文使用Spring Cloud和Netflix的Eureka服务发现引擎来实现服务发现模式。<br>客户端负载均衡，使用Spring Cloud和Netflix的Ribbon库</p><p>本文源码可在此找到：<a href="https://github.com/Alexaccele/SpringCloudDemo" target="_blank" rel="noopener">https://github.com/Alexaccele/SpringCloudDemo</a></p><h3 id="本文测试模块介绍"><a href="#本文测试模块介绍" class="headerlink" title="本文测试模块介绍"></a>本文测试模块介绍</h3><p><img src="https://img-blog.csdnimg.cn/201906271625456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTk1MzM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="构建Eureka服务——服务代理"><a href="#构建Eureka服务——服务代理" class="headerlink" title="构建Eureka服务——服务代理"></a>构建Eureka服务——服务代理</h3><h4 id="添加maven依赖"><a href="#添加maven依赖" class="headerlink" title="添加maven依赖"></a>添加maven依赖</h4><p>除了引入spring cloud以外，主要引入如下依赖，以支持Eureka库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8761  #Eureka服务端口</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    registerWithEureka: false #Eureka服务 本身不进行服务注册</span><br><span class="line">    fetch-registry: false #Eureka服务 本身不进行本地缓存注册表信息</span><br><span class="line">#  server:</span><br><span class="line">#    waitTimeInMsWhenSyncEmpty: 5 #等待其他待注册服务5min，让所有服务有机会在通告它们之前通过Eureka进行注册</span><br></pre></td></tr></table></figure><p>上面的最后一项属性在这里之所以注释掉，是为了能够快速的启动Eureka服务。</p><h4 id="Eureka服务启动类"><a href="#Eureka服务启动类" class="headerlink" title="Eureka服务启动类"></a>Eureka服务启动类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaServer//启动Eureka服务</span><br><span class="line">public class EurekaServerApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重要的只是@EnableEurekaServer注解，用于在spring服务中启动Eureka服务器。</p><h3 id="将服务注册到Eureka服务器"><a href="#将服务注册到Eureka服务器" class="headerlink" title="将服务注册到Eureka服务器"></a>将服务注册到Eureka服务器</h3><h4 id="添加maven依赖-1"><a href="#添加maven依赖-1" class="headerlink" title="添加maven依赖"></a>添加maven依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>引入Eureka库，以便可以用Eureka进行服务注册</p><h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: getinfo-service</span><br><span class="line">  profiles:</span><br><span class="line">    active: default</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true  #注册服务的IP，而不是服务器名称</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    fetch-registry: true</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka #Eureka服务位置</span><br><span class="line">server:</span><br><span class="line">  port: 8090</span><br></pre></td></tr></table></figure><p>其中的spring.application.name属性应该写在bootstrap.yml配置文件中，用于确定该服务的应用程序ID，而其余配置则应该写入我们通常所使用的application.yml文件中。</p><p>注意当多个服务要部署在本地时，应该注意区别每个服务的端口号应该不能冲突。</p><p>此时运行两个应用程序，可以在 <a href="http://localhost:8761/eureka/apps" target="_blank" rel="noopener">http://localhost:8761/eureka/apps</a> 中查看相关注册服务的信息。</p><h3 id="使用服务发现来查找服务"><a href="#使用服务发现来查找服务" class="headerlink" title="使用服务发现来查找服务"></a>使用服务发现来查找服务</h3><h4 id="使用Spring-DiscoveryClient查找服务实例"><a href="#使用Spring-DiscoveryClient查找服务实例" class="headerlink" title="使用Spring DiscoveryClient查找服务实例"></a>使用Spring DiscoveryClient查找服务实例</h4><p>首先在该应用程序的引导类中加入<code>@EnableDiscoveryClient</code>注解，使应用程序能够使用DiscoveryClient和Ribbon库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class InfoDiscoveryClient &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    public String getInfo(String name)&#123;</span><br><span class="line">        RestTemplate restTemplate = new RestTemplate();</span><br><span class="line">        //获取对应服务的所有实例列表</span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;getinfo-service&quot;);</span><br><span class="line">        if(instances.size() == 0)return null;</span><br><span class="line">        String serviceUri = String.format(&quot;%s/getInfo/%s&quot;,</span><br><span class="line">                instances.get(0).getUri().toString(),</span><br><span class="line">                name);//得到服务实例位置</span><br><span class="line">        //使用标准的Spring REST模板类调用该服务实例</span><br><span class="line">        ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(serviceUri, HttpMethod.GET, null, String.class, name);</span><br><span class="line">        return exchange.getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用带有Ribbon功能的Spring-RestTemplate调用服务"><a href="#使用带有Ribbon功能的Spring-RestTemplate调用服务" class="headerlink" title="使用带有Ribbon功能的Spring RestTemplate调用服务"></a>使用带有Ribbon功能的Spring RestTemplate调用服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class InfoRibbonClient &#123;</span><br><span class="line">    @LoadBalanced</span><br><span class="line">    @Bean</span><br><span class="line">    private RestTemplate getRestTemplate()&#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    public String getInfo(String name)&#123;</span><br><span class="line">        ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(&quot;http://getifo-service/getInfo/&#123;name&#125;&quot;,</span><br><span class="line">                HttpMethod.GET,</span><br><span class="line">                null, String.class, name);</span><br><span class="line">        return exchange.getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要将Ribbon和RestTemplate一起使用，必须使用<code>@LoadBalanced</code>注解进行显示标注</p><h4 id="调用服务发现"><a href="#调用服务发现" class="headerlink" title="调用服务发现"></a>调用服务发现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class getInfoController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    InfoDiscoveryClient discoveryClient;</span><br><span class="line">    @Autowired</span><br><span class="line">    InfoRibbonClient ribbonClient;</span><br><span class="line">    @GetMapping(&quot;/getInfo/&#123;name&#125;/&#123;type&#125;&quot;)</span><br><span class="line">    private String getInfoByDiscovery(@PathVariable String name, @PathVariable(name = &quot;type&quot;) String discoveryType)&#123;</span><br><span class="line">        String info = null;</span><br><span class="line">        switch (discoveryType)&#123;</span><br><span class="line">            case &quot;discovery&quot;:</span><br><span class="line">                System.out.println(&quot;use discovery client&quot;);</span><br><span class="line">                info = discoveryClient.getInfo(name);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;ribbon&quot;:</span><br><span class="line">                System.out.println(&quot;use ribbon client&quot;);</span><br><span class="line">                info = ribbonClient.getInfo(name);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                info = discoveryClient.getInfo(name);</span><br><span class="line">        &#125;</span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h3><p>一个简单的服务提供者，实现获取相应信息的服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@RestController</span><br><span class="line">public class GetinfoServiceApplication &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/getInfo/&#123;name&#125;&quot;)</span><br><span class="line">    public String getInfo(@PathVariable String name)&#123;</span><br><span class="line">        return &quot;It&apos;s &quot; + name + &quot;&apos;s info: ......&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(GetinfoServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动服务发现代理之后，再启动服务提供者和服务消费者，并在postman中进行测试，结果如下：<br><img src="https://img-blog.csdnimg.cn/2019062716370935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTk1MzM1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>服务消费者成功的调用了注册在服务代理中的服务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在任何分布式架构中，都需要找到机器所在的物理地址，这个过程称为服务发现。&lt;/p&gt;
&lt;p&gt;服务发现的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以快速对环境中运行的服务实例数量进行水平伸缩&lt;/li&gt;
&lt;li&gt;将服务的物理位置抽象，由于服务消费者不知道实际服务实例的物理位置，因此可以从
      
    
    </summary>
    
      <category term="微服务" scheme="Alexaccele.github.io.git/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="Alexaccele.github.io.git/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Eureka" scheme="Alexaccele.github.io.git/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>集合类实现原理总结</title>
    <link href="Alexaccele.github.io.git/2019/04/20/%E9%9B%86%E5%90%88%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"/>
    <id>Alexaccele.github.io.git/2019/04/20/集合类实现原理总结/</id>
    <published>2019-04-20T10:59:03.000Z</published>
    <updated>2020-04-16T08:29:12.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合类实现原理总结"><a href="#集合类实现原理总结" class="headerlink" title="集合类实现原理总结"></a>集合类实现原理总结</h1><h2 id="整体认识"><a href="#整体认识" class="headerlink" title="整体认识"></a>整体认识</h2><p>这里贴出一张网上某大神制作的关于集合类的整体结构关系</p><p><img src="https://i.imgur.com/xAiWVkO.png" alt></p><p>此图转载自 <a href="https://blog.csdn.net/u010887744/article/details/50575735" target="_blank" rel="noopener"> https://blog.csdn.net/u010887744/article/details/50575735</a></p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList——非线程安全"><a href="#ArrayList——非线程安全" class="headerlink" title="ArrayList——非线程安全"></a>ArrayList——非线程安全</h3><h4 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h4><p>ArrayList的内部结构其实就是一个数组。</p><p>由于是数组结构，故访问时间复杂度为O(1)，插入删除的时间复杂度为O(n)。</p><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>ArrayList的默认大小是10个元素，当容量不够时，则需要扩容，而扩容的大小是原来的1.5倍(JDK1.8)，其实现代码如下：</p><pre><code>private void grow(int minCapacity) {    // overflow-conscious code    int oldCapacity = elementData.length;    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    // minCapacity is usually close to size, so this is a win:    elementData = Arrays.copyOf(elementData, newCapacity);}</code></pre><p>其决定新数组大小的则是<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code></p><p>可以看出采用的是位运算得出原来的一半，再加上原来的大小，则得出了1.5倍。<br>而扩容的行为则是通过<code>Arrays.copyOf(elementData, newCapacity);</code>将原来的数组内容复制到新的数组中。</p><blockquote><p>补充</p><p>关于网上部分文章提到的扩容为原来的1.5倍+1，其实是JDK1.6中的实现。扩容值算法如下：</p><p>int var4 = var2 * 3 / 2 + 1;</p><p>而自从JDK1.7开始则是采用位运算实现，故没有了后面的+1.</p></blockquote><a id="more"></a><h3 id="LinkedList——非线程安全"><a href="#LinkedList——非线程安全" class="headerlink" title="LinkedList——非线程安全"></a>LinkedList——非线程安全</h3><h4 id="内部结构-1"><a href="#内部结构-1" class="headerlink" title="内部结构"></a>内部结构</h4><p>采用双向链表实现，故插入的时间复杂度是O(1)，而查询的时间复杂度是O(n)</p><p>由于还实现了Deque接口，故还可以用作双端队列</p><p>由于是链表结构，故只要是遍历链表就需要使用ListIterator</p><p>采用了索引优化，可以根据index选择从first或者last开始遍历。</p><h3 id="Vector——线程安全"><a href="#Vector——线程安全" class="headerlink" title="Vector——线程安全"></a>Vector——线程安全</h3><h4 id="内部结构-2"><a href="#内部结构-2" class="headerlink" title="内部结构"></a>内部结构</h4><p>与ArrayList相同，采用数组的形式实现</p><p>初始大小10，最大容量Integer.MAX_VALUE - 8。</p><h4 id="扩容机制-1"><a href="#扩容机制-1" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>扩容为原来的两倍</p><pre><code>private void grow(int minCapacity) {    // overflow-conscious code    int oldCapacity = elementData.length;    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?                                     capacityIncrement : oldCapacity);    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    elementData = Arrays.copyOf(elementData, newCapacity);}</code></pre><h4 id="线程安全的实现"><a href="#线程安全的实现" class="headerlink" title="线程安全的实现"></a>线程安全的实现</h4><p>所有可能发生竞争的方法都采用synchronized关键字实现，故效率极低，现在已经不再使用。</p><p>若要使用线程安全的List则应该使用CopyOnWriteArrayList。</p><h3 id="CopyOnWriteArrayList——线程安全"><a href="#CopyOnWriteArrayList——线程安全" class="headerlink" title="CopyOnWriteArrayList——线程安全"></a>CopyOnWriteArrayList——线程安全</h3><p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p><h4 id="写锁的实现"><a href="#写锁的实现" class="headerlink" title="写锁的实现"></a>写锁的实现</h4><p>只在写的时候对数组加锁，采用的是ReentrantLock，加锁之后再复制原来的数组到新数组中，并添加新的元素。</p><p>在这个加锁的期间，由于其他线程仍然可以进行读操作，但读的数组是加锁前的旧数组，因此可能会读到原来的旧数据。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>适合用在读多写少的场景，即可以并发的读而不需要额外的同步操作，只有少量的写操作需要依靠锁来保证线程安全。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap——非线程安全"><a href="#HashMap——非线程安全" class="headerlink" title="HashMap——非线程安全"></a>HashMap——非线程安全</h3><h4 id="内部结构-3"><a href="#内部结构-3" class="headerlink" title="内部结构"></a>内部结构</h4><p>HashMap中主干是一个Node数组，每个Node包含一个key-value的键值对。</p><pre><code>transient Node&lt;k,v&gt;[] table;//存储（位桶）的数组&lt;/k,v&gt;</code></pre><p>Node是HashMap的一个静态内部类。</p><pre><code>//Node是单向链表，它实现了Map.Entry接口static class Node&lt;k,v&gt; implements Map.Entry&lt;k,v&gt; {    final int hash;    final K key;    V value;    Node&lt;k,v&gt; next;    //构造函数Hash值 键 值 下一个节点    Node(int hash, K key, V value, Node&lt;k,v&gt; next) {        this.hash = hash;        this.key = key;        this.value = value;        this.next = next;    }    public final K getKey()        { return key; }    public final V getValue()      { return value; }    public final String toString() { return key + = + value; }    public final int hashCode() {        return Objects.hashCode(key) ^ Objects.hashCode(value);    }    public final V setValue(V newValue) {        V oldValue = value;        value = newValue;        return oldValue;    }    //判断两个node是否相等,若key和value都相等，返回true。可以与自身比较为true    public final boolean equals(Object o) {        if (o == this)            return true;        if (o instanceof Map.Entry) {            Map.Entry&lt;!--?,?--&gt; e = (Map.Entry&lt;!--?,?--&gt;)o;            if (Objects.equals(key, e.getKey()) &amp;&amp;                Objects.equals(value, e.getValue()))                return true;        }        return false;}</code></pre><h4 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h4><p>在HashMap中是以数组（也称为位桶）+ 链表 + (红黑树)的形式存在，当hash值冲突时，则以链表的形式解决hash冲突。</p><h4 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h4><p>在JDK1.8中则更是增加了红黑树的结构，当链表的长度超过阈值8时，则会将这部分hash冲突的链表转为红黑树，这样的目的在于，当HashMap中的hash冲突过多而导致链表过长时，仍能较快速的查找到对应的value值，即从以前的 O(n)变为了O(log(n))。</p><blockquote><p>补充</p><p>当链表长度超过8时，还要判断当前的map集合中是否总数量达到了64个，如果没有达到的话，不是进行红黑树的转换，而是直接进行扩容。</p></blockquote><h4 id="扩容机制-2"><a href="#扩容机制-2" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>构造hash表时，如果不指明初始大小，默认大小为16（即Node数组大小16）</p><p>当链表数组的容量超过初始容量的0.75倍（负载因子）时，再散列将链表数组扩大2倍，把原链表数组的搬移到新的数组中。</p><blockquote><p>为什么要扩容？为什么需要使用负载因子</p><p>因为如果填充比很大，说明利用的空间很多，如果一直不进行扩容的话，链表就会越来越长，这样查找的效率很低，因为链表的长度很大（JDK1.8使用了红黑树后会改进很多），扩容之后，将原来链表数组的每一个链表分成奇偶两个子链表分别挂在新链表数组的散列位置，这样就减少了每个链表的长度，增加查找效率。</p></blockquote><h3 id="LinkedHashMap——非线程安全"><a href="#LinkedHashMap——非线程安全" class="headerlink" title="LinkedHashMap——非线程安全"></a>LinkedHashMap——非线程安全</h3><p>LinkedHashMap继承自HashMap，大部分属性都类似，但HashMap不保证存储顺序，而LinkedHashMap会维护元素的顺序，顺序可分为访问顺序和插入顺序，默认是保证插入顺序（即迭代遍历的顺序是元素插入的顺序）</p><pre><code>// 第三个参数用于指定accessOrder值Map&lt;String, String&gt; linkedHashMap = new LinkedHashMap&lt;&gt;(16, 0.75f, true);</code></pre><p>通过以上构造函数，可以指定accessOrder的值为true从而使其保证访问顺序，访问顺序是指，当每次调用get()方法后，对应的key-value键值对则被放在了链表的尾部。</p><h4 id="内部结构-4"><a href="#内部结构-4" class="headerlink" title="内部结构"></a>内部结构</h4><p>LinkedHashMap是由一个双向链表组成。</p><p>LinkedHashMap使用的是LRU算法(最近最少使用) 。当你插入元素时它会将节点插入双向链表的链尾，如果key重复，则也会将节点移动至链尾，当用get()方法获取value时也会将节点移动至链尾。 </p><h3 id="TreeMap——非线程安全"><a href="#TreeMap——非线程安全" class="headerlink" title="TreeMap——非线程安全"></a>TreeMap——非线程安全</h3><h3 id="内部结构-5"><a href="#内部结构-5" class="headerlink" title="内部结构"></a>内部结构</h3><p>基于红黑树实现</p><h4 id="排序方式"><a href="#排序方式" class="headerlink" title="排序方式"></a>排序方式</h4><p>其映射根据键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。其基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n) 。TreeMap是非同步的。 它的iterator 方法返回的迭代器是fail-fastl的。</p><p>当自定义比较器时，需要自定义类实现java.lang.Comparable接口，并重写compareTo()方法。</p><p>相比较于LinkedHashMap的保证插入顺序，TreeMap是在元素的内容上有序（相当于内容排序）</p><h3 id="HashTable——线程安全"><a href="#HashTable——线程安全" class="headerlink" title="HashTable——线程安全"></a>HashTable——线程安全</h3><p>现在已经不再使用，其线程安全的实现方式是所有的方法都是synchronized方法，故虽然保证了线程安全，但效率很低。若需要使用线程安全的Map则应该使用ConcurrentHashMap。</p><p>底层数组+链表实现，无论key还是value都不能为null，线程安全，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化</p><p>初始size为11，扩容：newsize = olesize*2+1</p><h3 id="ConcurrentHashMap——线程安全"><a href="#ConcurrentHashMap——线程安全" class="headerlink" title="ConcurrentHashMap——线程安全"></a>ConcurrentHashMap——线程安全</h3><h4 id="内部结构-6"><a href="#内部结构-6" class="headerlink" title="内部结构"></a>内部结构</h4><p>在JDK1.7中采用的是ReentrantLock+Segment+HashEntry的结构</p><p>在JDK1.8中则是采用数组+链表+红黑树的结构，其线程安全的保证则是通过synchronized+CAS的形式。</p><h4 id="线程安全实现机制"><a href="#线程安全实现机制" class="headerlink" title="线程安全实现机制"></a>线程安全实现机制</h4><p>在JDK1.7中采用分段锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。</p><p>而在JDK1.8中则直接参考了JDK1.8中HashMap的结构，采用数组+链表+红黑树的结构，而线程安全则是通过CAS来实现。而锁的细粒度也从JDK1.7中的segment段降低为了JDK1.8中的每个Node，且由于红黑树的引入，使得在当链表节点过多的情况下能提高查询效率。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>由于Set底层都是采用对应的Map实现，所以不再赘述。</p><p>需要注意的是在Set中，Map对应的key则是对应的Set的值，而Map对应的value则是采用同一个Object对象</p><pre><code>// Dummy value to associate with an Object in the backing Mapprivate static final Object PRESENT = new Object();</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;集合类实现原理总结&quot;&gt;&lt;a href=&quot;#集合类实现原理总结&quot; class=&quot;headerlink&quot; title=&quot;集合类实现原理总结&quot;&gt;&lt;/a&gt;集合类实现原理总结&lt;/h1&gt;&lt;h2 id=&quot;整体认识&quot;&gt;&lt;a href=&quot;#整体认识&quot; class=&quot;headerlink&quot; title=&quot;整体认识&quot;&gt;&lt;/a&gt;整体认识&lt;/h2&gt;&lt;p&gt;这里贴出一张网上某大神制作的关于集合类的整体结构关系&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/xAiWVkO.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;此图转载自 &lt;a href=&quot;https://blog.csdn.net/u010887744/article/details/50575735&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; https://blog.csdn.net/u010887744/article/details/50575735&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;List&quot;&gt;&lt;a href=&quot;#List&quot; class=&quot;headerlink&quot; title=&quot;List&quot;&gt;&lt;/a&gt;List&lt;/h2&gt;&lt;h3 id=&quot;ArrayList——非线程安全&quot;&gt;&lt;a href=&quot;#ArrayList——非线程安全&quot; class=&quot;headerlink&quot; title=&quot;ArrayList——非线程安全&quot;&gt;&lt;/a&gt;ArrayList——非线程安全&lt;/h3&gt;&lt;h4 id=&quot;内部结构&quot;&gt;&lt;a href=&quot;#内部结构&quot; class=&quot;headerlink&quot; title=&quot;内部结构&quot;&gt;&lt;/a&gt;内部结构&lt;/h4&gt;&lt;p&gt;ArrayList的内部结构其实就是一个数组。&lt;/p&gt;
&lt;p&gt;由于是数组结构，故访问时间复杂度为O(1)，插入删除的时间复杂度为O(n)。&lt;/p&gt;
&lt;h4 id=&quot;扩容机制&quot;&gt;&lt;a href=&quot;#扩容机制&quot; class=&quot;headerlink&quot; title=&quot;扩容机制&quot;&gt;&lt;/a&gt;扩容机制&lt;/h4&gt;&lt;p&gt;ArrayList的默认大小是10个元素，当容量不够时，则需要扩容，而扩容的大小是原来的1.5倍(JDK1.8)，其实现代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);
    if (newCapacity - minCapacity &amp;lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其决定新数组大小的则是&lt;code&gt;int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以看出采用的是位运算得出原来的一半，再加上原来的大小，则得出了1.5倍。&lt;br&gt;而扩容的行为则是通过&lt;code&gt;Arrays.copyOf(elementData, newCapacity);&lt;/code&gt;将原来的数组内容复制到新的数组中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;补充&lt;/p&gt;
&lt;p&gt;关于网上部分文章提到的扩容为原来的1.5倍+1，其实是JDK1.6中的实现。扩容值算法如下：&lt;/p&gt;
&lt;p&gt;int var4 = var2 * 3 / 2 + 1;&lt;/p&gt;
&lt;p&gt;而自从JDK1.7开始则是采用位运算实现，故没有了后面的+1.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="实现原理" scheme="Alexaccele.github.io.git/categories/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="集合类" scheme="Alexaccele.github.io.git/tags/%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
      <category term="原理" scheme="Alexaccele.github.io.git/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机中多态的实现方式</title>
    <link href="Alexaccele.github.io.git/2019/04/19/%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>Alexaccele.github.io.git/2019/04/19/虚拟机中多态的实现方式/</id>
    <published>2019-04-19T11:41:07.000Z</published>
    <updated>2020-04-16T08:29:12.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟机中多态的实现方式"><a href="#虚拟机中多态的实现方式" class="headerlink" title="虚拟机中多态的实现方式"></a>虚拟机中多态的实现方式</h1><p>多态的表现形式分为重载和重写。</p><ul><li><p>重载是指同一类中的同名方法不同参数列表的表现形式，是一种静态的多态。</p></li><li><p>重写是指具有继承关系的多个类中子类对父类方法的重写，是一种动态的多态。</p><a id="more"></a></li></ul><p>而在虚拟机中，对这两种多态的表现形式有着不同的实现方式。</p><h2 id="重载的实现——静态分派"><a href="#重载的实现——静态分派" class="headerlink" title="重载的实现——静态分派"></a>重载的实现——静态分派</h2><p>虚拟机中在重载时是通过参数的静态类型作为判断类型的，并且静态类型是编译期可知的，所以在编译阶段，Javac编译器就会根据参数的静态类型决定使用哪个重载版本。</p><p>即对于重载，方法匹配的是声明时的变量类型，而不是实际类型。</p><p>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。</p><p>对于静态方法会在类加载期就进行解析，而静态方法显然也是可以重载，这个过程同样是通过静态分派完成。</p><h2 id="重写的实现——动态分派"><a href="#重写的实现——动态分派" class="headerlink" title="重写的实现——动态分派"></a>重写的实现——动态分派</h2><p>对应重写是在虚拟机运行期根据实际类型确定方法执行版本的，这种分派过程称为动态分派。</p><p>重写实现过程：</p><ul><li>首先是在运行期根据对象的实际类型在本类中查找符合的方法，若找到则进行访问权限校验（即private、protected、public、default等权限），如果通过则匹配成功，返回这个方法的直接引用，查找结束，如果没有通过权限，则返回java.lang.IllegalAccessError异常。</li><li>若在本类中未找到符合的方法，则按照继承关系从下到上以此对其父类进行查找和权限验证的过程。</li><li>如果最后仍没有找到符合的方法，则抛出java.lang.AbstractMethodError异常。</li></ul><p>由于动态分派是非常频繁的动作，为了提高这种搜索的效率，通常会为类在方法区建立一个虚方法表（Virtual Method Table,vtable）。</p><p>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那么子类的虚方法表中存放的则是父类的相同方法的入口地址，指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址则会替换为指向子类实现版本的入口地址。</p><h2 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h2><p>对于重载采用的是静态分派，匹配方法的参数是静态类型（即声明时的变量类型）。</p><p>而对于重写则采用的是动态分派，匹配方法的参数是实际类型（即new对象的实际类型）。</p><blockquote><p>对于具体的详细分析，可以参考《深入理解Java虚拟机》中的8.3节</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;虚拟机中多态的实现方式&quot;&gt;&lt;a href=&quot;#虚拟机中多态的实现方式&quot; class=&quot;headerlink&quot; title=&quot;虚拟机中多态的实现方式&quot;&gt;&lt;/a&gt;虚拟机中多态的实现方式&lt;/h1&gt;&lt;p&gt;多态的表现形式分为重载和重写。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;重载是指同一类中的同名方法不同参数列表的表现形式，是一种静态的多态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重写是指具有继承关系的多个类中子类对父类方法的重写，是一种动态的多态。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="Alexaccele.github.io.git/categories/JVM/"/>
    
    
      <category term="JVM" scheme="Alexaccele.github.io.git/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>使用Spring Cloud Config配置服务器控制配置</title>
    <link href="Alexaccele.github.io.git/2019/02/19/%E4%BD%BF%E7%94%A8Spring%20Cloud%20Config%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A7%E5%88%B6%E9%85%8D%E7%BD%AE/"/>
    <id>Alexaccele.github.io.git/2019/02/19/使用Spring Cloud Config配置服务器控制配置/</id>
    <published>2019-02-19T11:37:07.000Z</published>
    <updated>2020-04-16T08:29:12.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Spring-Cloud-Config配置服务器控制配置"><a href="#使用Spring-Cloud-Config配置服务器控制配置" class="headerlink" title="使用Spring Cloud Config配置服务器控制配置"></a>使用Spring Cloud Config配置服务器控制配置</h1><h2 id="Spring-Cloud-Config介绍"><a href="#Spring-Cloud-Config介绍" class="headerlink" title="Spring Cloud Config介绍"></a>Spring Cloud Config介绍</h2><p>Spring Cloud Config是Sping-Cloud下用于分布式配置管理的组件，分成了两个角色Config-Server和Config-Client；</p><p>Config-Server端（即配置服务器）集中式存储/管理配置文件，并对外提供接口方便Config-Client访问，接口使用HTTP的方式对外提供访问；Config-Server存储/管理的配置文件可以来自本地文件，远程Git仓库以及远程Svn仓库</p><p>Config-Client（需要获取配置文件的各种微服务）通过接口获取配置文件，然后可以在应用中使用；</p><p>Spring Cloud配置服务器是基于REST的应用程序，它不是独立服务器，开发人员可以选择将它嵌入现有的springboot应用程序中，也可以在嵌入它的服务器中启动新的springboot项目<br><a id="more"></a></p><h2 id="构建Spring-Cloud配置服务器————Config-Server"><a href="#构建Spring-Cloud配置服务器————Config-Server" class="headerlink" title="构建Spring Cloud配置服务器————Config-Server"></a>构建Spring Cloud配置服务器————Config-Server</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>首先为springcloud配置服务器添加maven依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>关于pom文件的详细信息可以在文章开头给出的GitHub中找到。</p><h3 id="创建引导类"><a href="#创建引导类" class="headerlink" title="创建引导类"></a>创建引导类</h3><p>为springcloud配置服务器创建一个引导类ConfigServerApplication</p><pre><code>import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.config.server.EnableConfigServer;@SpringBootApplication@EnableConfigServerpublic class ConfigServerApplication {    public static void main(String[] args) {        SpringApplication.run(ConfigServerApplication.class, args);    }}</code></pre><p><code>@EnableConfigServer</code>注解使得该应用程序成为一个spring cloud config服务器</p><h3 id="添加配置文件application-yml"><a href="#添加配置文件application-yml" class="headerlink" title="添加配置文件application.yml"></a>添加配置文件application.yml</h3><pre><code>spring:      application:        name: config-server      profiles:        active:              native      cloud:        config:              server:                native:                      search-locations: classpath:configs/,configs/config-clientserver:      port: 8888</code></pre><p>在这里指出了该服务的名称为config-server，但这类配置应该写入bootstrap.yml文件中，这里因为不会影响测试功能所以写在application.yml中。具体原因会在后面解释。</p><p>指定了配置文件为文件系统，即从配置服务器本地读取。</p><p>接着指出了本地配置文件的读取位置为<code>classpath:configs/,configs/config-client</code></p><p>最后则是配置服务器的默认监听端口8888</p><h4 id="从Git仓库远程读取配置文件"><a href="#从Git仓库远程读取配置文件" class="headerlink" title="从Git仓库远程读取配置文件"></a>从Git仓库远程读取配置文件</h4><p>若需要使用Git作为配置文件的远程仓库则可以将配置文件application.yml对应属性更改为</p><pre><code>spring.cloud.config.server.git.uri=https://github.com/XXX/XXX #表示对应的Git存储库的URLspring.cloud.config.server.git.searchPaths=config-client #表示Git中查找配置文件的路径#Git的用户名和密码，若为公开Git仓库则可以为空，若为私人Git仓库则必须填写spring.cloud.config.server.git.username=spring.cloud.config.server.git.password=</code></pre><h3 id="准备config-client要使用的配置文件"><a href="#准备config-client要使用的配置文件" class="headerlink" title="准备config-client要使用的配置文件"></a>准备config-client要使用的配置文件</h3><p>在本地resources中创建上一步中所涉及的目录configs，在configs下创建文件config-client-dev.yml,内容如下</p><pre><code>test: &quot;This is a spring cloud config test&quot;</code></pre><p>这里为做测试，故自定义一个配置属性，将为config-client中注入属性做准备。<br>类似的配置文件可以有<code>config-client.yml / config-client-pro.yml / config-client-test.yml</code></p><h3 id="启动配置服务器"><a href="#启动配置服务器" class="headerlink" title="启动配置服务器"></a>启动配置服务器</h3><p>此时已经可以启动配置服务器了，可以在工程所在目录下的命令行中使用<code>mvn spring-boot:run</code>运行。<br>此时在浏览器中可以通过多种方式查看配置文件的信息，例如<code>http://localhost:8888/config-client/dev</code>，结果显示如下，则说明成功。</p><p><img src="https://i.imgur.com/WAH5CQb.png" alt></p><p>支持的查看方式有如下几种：</p><pre><code>/{application}/{profile}[/{label}]/{application}-{profile}.yml/{label}/{application}-{profile}.yml/{application}-{profile}.properties/{label}/{application}-{profile}.properties</code></pre><ul><li>application对应相应服务的名称，本案例是指config-client，后文创建config-client服务时会在bootstrap.yml文件中指出；</li><li>profile表示使用哪种环境的配置文件，这里可以是dev，test，pro，甚至是default表示上面提到的config-client.yml文件，即没有代表环境的后缀；</li><li>label是可选的标签，git仓库默认值master，svn仓库默认值是trunk；</li></ul><h2 id="config-client端的搭建"><a href="#config-client端的搭建" class="headerlink" title="config-client端的搭建"></a>config-client端的搭建</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>在新的config-client项目的pom文件中添加如下依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="创建配置文件bootstrap-yml"><a href="#创建配置文件bootstrap-yml" class="headerlink" title="创建配置文件bootstrap.yml"></a>创建配置文件bootstrap.yml</h3><pre><code>spring:  application:    name: config-client  cloud:    config:      uri: http://localhost:8888      fail-fast: true  profiles:    active: devserver:  port: 8080</code></pre><p>在配置中分别指出了该应用程序的名称和配置文件所在路径，以及配置文件的环境为dev即开发环境。即对应上文中描述的几种类型。开放了监听端口8080</p><p>注意这里的spring.application.name属性和spring.cloud.config.uri/fail-fast属性的配置写在bootstrap.yml文件中是规范的，若将spring.cloud.config.uri/fail-fast属性写入application.yml文件中，则会导致项目在启动过程中报错，原因就是找不到对应的配置文件，在这里就是上文中的config-client-dev.yml。</p><h3 id="写入bootstrap-yml的原因"><a href="#写入bootstrap-yml的原因" class="headerlink" title="写入bootstrap.yml的原因"></a>写入bootstrap.yml的原因</h3><p>将spring.application.name属性和spring.cloud.config.uri属性的配置写在bootstrap.yml文件原因是在启动过程中，加载bootstrap.yml文件的顺序要优先于application.yml。</p><p>详细原因可以参考这篇文章：<a href="https://www.cnblogs.com/BlogNetSpace/p/8469033.html" target="_blank" rel="noopener">https://www.cnblogs.com/BlogNetSpace/p/8469033.html</a></p><h3 id="在config-client引导类中添加API接口"><a href="#在config-client引导类中添加API接口" class="headerlink" title="在config-client引导类中添加API接口"></a>在config-client引导类中添加API接口</h3><pre><code>import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@SpringBootApplication@RestControllerpublic class ConfigClientApplication {    @Value(&quot;${test}&quot;)    String test;    @GetMapping(&quot;/test&quot;)    public String test(){        return test;    }    public static void main(String[] args) {        SpringApplication.run(ConfigClientApplication.class, args);    }}</code></pre><p>@Value读取配置文件中的test属性，即上文在config-server中的配置文件config-client-dev.yml中的test属性。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://i.imgur.com/D6cOmpb.png" alt></p><p>可以看到浏览器中返回的结果，与我们想要读取的配置文件中的内容一致。</p><p>这就是Spring Cloud Config 的一个简单演示，仅仅通过一些简单步骤就实现了配置文件和应用程序的完全分离，这在实际生产中的作用是巨大的。</p><p>个人博客地址:<a href="https://alexaccele.github.io/" target="_blank" rel="noopener">https://alexaccele.github.io/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用Spring-Cloud-Config配置服务器控制配置&quot;&gt;&lt;a href=&quot;#使用Spring-Cloud-Config配置服务器控制配置&quot; class=&quot;headerlink&quot; title=&quot;使用Spring Cloud Config配置服务器控制配置&quot;&gt;&lt;/a&gt;使用Spring Cloud Config配置服务器控制配置&lt;/h1&gt;&lt;h2 id=&quot;Spring-Cloud-Config介绍&quot;&gt;&lt;a href=&quot;#Spring-Cloud-Config介绍&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud Config介绍&quot;&gt;&lt;/a&gt;Spring Cloud Config介绍&lt;/h2&gt;&lt;p&gt;Spring Cloud Config是Sping-Cloud下用于分布式配置管理的组件，分成了两个角色Config-Server和Config-Client；&lt;/p&gt;
&lt;p&gt;Config-Server端（即配置服务器）集中式存储/管理配置文件，并对外提供接口方便Config-Client访问，接口使用HTTP的方式对外提供访问；Config-Server存储/管理的配置文件可以来自本地文件，远程Git仓库以及远程Svn仓库&lt;/p&gt;
&lt;p&gt;Config-Client（需要获取配置文件的各种微服务）通过接口获取配置文件，然后可以在应用中使用；&lt;/p&gt;
&lt;p&gt;Spring Cloud配置服务器是基于REST的应用程序，它不是独立服务器，开发人员可以选择将它嵌入现有的springboot应用程序中，也可以在嵌入它的服务器中启动新的springboot项目&lt;br&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="Alexaccele.github.io.git/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="Alexaccele.github.io.git/tags/SpringCloud/"/>
    
      <category term="SpringCloudConfig" scheme="Alexaccele.github.io.git/tags/SpringCloudConfig/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化——剖析单条查询</title>
    <link href="Alexaccele.github.io.git/2019/02/17/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E5%89%96%E6%9E%90%E5%8D%95%E6%9D%A1%E6%9F%A5%E8%AF%A2/"/>
    <id>Alexaccele.github.io.git/2019/02/17/MySQL性能优化——剖析单条查询/</id>
    <published>2019-02-17T08:04:35.000Z</published>
    <updated>2020-04-16T08:29:12.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL性能优化——剖析单条查询"><a href="#MySQL性能优化——剖析单条查询" class="headerlink" title="MySQL性能优化——剖析单条查询"></a>MySQL性能优化——剖析单条查询</h1><h2 id="EXPLAIN-的使用"><a href="#EXPLAIN-的使用" class="headerlink" title="EXPLAIN 的使用"></a>EXPLAIN 的使用</h2><p>EXPLAIN的使用非常简单，就在你要进行的查询语句前跟上 EXPLAIN 即可。<br>例如：<br><a id="more"></a></p><pre><code>mysql&gt; EXPLAIN SELECT * FROM house limit 5\G;*************************** 1. row ***************************               id: 1   select_type: SIMPLE         table: house    partitions: NULL          type: ALL possible_keys: NULL           key: NULL       key_len: NULL           ref: NULL          rows: 9      filtered: 100.00         Extra: NULL1 row in set, 1 warning (0.06 sec)</code></pre><p>或者去掉\G</p><pre><code>mysql&gt; EXPLAIN SELECT * FROM house limit 5;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+|  1 | SIMPLE      | house | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    9 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+1 row in set, 1 warning (0.00 sec)</code></pre><p>各列的含义如下:</p><ul><li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li><li>select_type: SELECT 查询的类型.</li><li>table: 查询的是哪个表</li><li>partitions: 匹配的分区</li><li>type: join 类型</li><li>possible_keys: 此次查询中可能选用的索引</li><li>key: 此次查询中确切使用到的索引.</li><li>ref: 哪个字段或常数与 key 一起被使用</li><li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li><li>filtered: 表示此查询条件所过滤的数据的百分比</li><li>extra: 额外的信息</li></ul><h2 id="使用-SHOW-PROFILE"><a href="#使用-SHOW-PROFILE" class="headerlink" title="使用 SHOW PROFILE"></a>使用 SHOW PROFILE</h2><p>开启show profile</p><p><code>mysql&gt; SET profiling = 1;</code></p><p>任意执行查询语句</p><p>例如， <code>mysql&gt; SELECT * FROM house limit 5；</code></p><p>之后再执行show profiles;<br>可以查看结果</p><pre><code>mysql&gt; show profiles;+----------+------------+-----------------------------+| Query_ID | Duration   | Query                       |+----------+------------+-----------------------------+|        1 | 0.00078075 | SELECT * FROM house limit 5 |+----------+------------+-----------------------------+1 row in set, 1 warning (0.00 sec)</code></pre><p>其中duration则是执行单条指令的查询响应时间。</p><p>通过指定profile的查询ID可以查看更加具体的信息</p><pre><code>mysql&gt; show profile for query 1;+----------------------+----------+| Status               | Duration |+----------------------+----------+| starting             | 0.000167 || checking permissions | 0.000020 || Opening tables       | 0.000079 || init                 | 0.000099 || System lock          | 0.000026 || optimizing           | 0.000010 || statistics           | 0.000030 || preparing            | 0.000023 || executing            | 0.000003 || Sending data         | 0.000138 || end                  | 0.000011 || query end            | 0.000022 || closing tables       | 0.000026 || freeing items        | 0.000108 || cleaning up          | 0.000021 |+----------------------+----------+15 rows in set, 1 warning (0.03 sec)</code></pre><p>使用show profile命令所得到的执行时间更加精确，这对我们分析查询语句并对其进行优化很有帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL性能优化——剖析单条查询&quot;&gt;&lt;a href=&quot;#MySQL性能优化——剖析单条查询&quot; class=&quot;headerlink&quot; title=&quot;MySQL性能优化——剖析单条查询&quot;&gt;&lt;/a&gt;MySQL性能优化——剖析单条查询&lt;/h1&gt;&lt;h2 id=&quot;EXPLAIN-的使用&quot;&gt;&lt;a href=&quot;#EXPLAIN-的使用&quot; class=&quot;headerlink&quot; title=&quot;EXPLAIN 的使用&quot;&gt;&lt;/a&gt;EXPLAIN 的使用&lt;/h2&gt;&lt;p&gt;EXPLAIN的使用非常简单，就在你要进行的查询语句前跟上 EXPLAIN 即可。&lt;br&gt;例如：&lt;br&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="Alexaccele.github.io.git/tags/MySQL/"/>
    
      <category term="性能优化" scheme="Alexaccele.github.io.git/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Docker的使用以及命令总结</title>
    <link href="Alexaccele.github.io.git/2019/02/17/Docker%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>Alexaccele.github.io.git/2019/02/17/Docker的使用以及命令总结/</id>
    <published>2019-02-17T07:54:46.000Z</published>
    <updated>2020-04-16T08:29:12.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="帮助相关"><a href="#帮助相关" class="headerlink" title="帮助相关"></a>帮助相关</h2><ul><li>docker –help 可以查看docker的所有命令（注意单词全拼的参数前都是两个‘-’号）</li><li>docker info 查看docker信息</li><li>docker version 查看docker版本号</li></ul><a id="more"></a><h3 id="最有用的帮助命令"><a href="#最有用的帮助命令" class="headerlink" title="最有用的帮助命令"></a>最有用的帮助命令</h3><p>docker XXX –help 查看具体命令的帮助手册（XXX代指各种命令）</p><h2 id="镜像相关"><a href="#镜像相关" class="headerlink" title="镜像相关"></a>镜像相关</h2><h3 id="docker-images-查看所有镜像"><a href="#docker-images-查看所有镜像" class="headerlink" title="docker images 查看所有镜像"></a>docker images 查看所有镜像</h3><p>参数说明：</p><ul><li>-a :列出本地所有的镜像（含中间映像层）</li><li>-q :只显示镜像ID。</li><li>–digests :显示镜像的摘要信息</li><li>–no-trunc :显示完整的镜像信息</li></ul><h3 id="docker-search-XXX-根据关键字搜索docker镜像"><a href="#docker-search-XXX-根据关键字搜索docker镜像" class="headerlink" title="docker search XXX 根据关键字搜索docker镜像"></a>docker search XXX 根据关键字搜索docker镜像</h3><p>参数说明：</p><ul><li>-s : 列出收藏数不小于指定值的镜像。</li><li>–limit int ：最大显示结果数(默认25个)</li><li>–no-trunc : 显示完整的镜像描述</li><li>–automated : 只列出 automated build类型的镜像；</li></ul><h3 id="docker-pull-XXX-下载镜像"><a href="#docker-pull-XXX-下载镜像" class="headerlink" title="docker pull XXX 下载镜像"></a>docker pull XXX 下载镜像</h3><p>可以使用docker pull XXX:Tag 具体指出下载某个Tag的镜像</p><h3 id="docker-rmi-ID-删除ID所指的镜像"><a href="#docker-rmi-ID-删除ID所指的镜像" class="headerlink" title="docker rmi ID 删除ID所指的镜像"></a>docker rmi ID 删除ID所指的镜像</h3><p>参数说明：</p><p>-f：强制删除</p><p>例子：</p><ul><li>删除单个镜像：docker rmi -f ID</li><li>删除多个镜像：docker rmi -f 镜像名1:TAG 镜像名2:TAG</li><li>删除全部镜像：docker rmi -f $(docker images -qa)</li></ul><h2 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h2><h3 id="docker-run-OPTIONS-IMAGE-COMMAND-ARG…-新建并启动容器"><a href="#docker-run-OPTIONS-IMAGE-COMMAND-ARG…-新建并启动容器" class="headerlink" title="docker run [OPTIONS] IMAGE [COMMAND] [ARG…] 新建并启动容器"></a>docker run [OPTIONS] IMAGE [COMMAND] [ARG…] 新建并启动容器</h3><p>参数说明：</p><ul><li>–name=”容器新名字”: 为容器指定一个名称</li><li>-d: 后台运行容器，并返回容器ID，也即启动守护式容器</li><li>-i：以交互模式运行容器，通常与 -t 同时使用</li><li>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用</li><li>-P: 随机端口映射</li><li><p>-p: 指定端口映射，有以下四种格式</p></li><li><p>ip:hostPort:containerPort</p></li><li>ip::containerPort</li><li>hostPort:containerPort</li><li>containerPort<br>启动交互式容器：使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。<code>docker run -it centos /bin/bash</code></li></ul><p>后台运行容器：<code>docker run -d centos</code></p><h3 id="docker-ps-查看所有正在运行的容器"><a href="#docker-ps-查看所有正在运行的容器" class="headerlink" title="docker ps 查看所有正在运行的容器"></a>docker ps 查看所有正在运行的容器</h3><p>参数说明：</p><ul><li>-a :列出当前所有正在运行的容器+历史上运行过的</li><li>-l :显示最近创建的容器。</li><li>-n：显示最近n个创建的容器。</li><li>-q :静默模式，只显示容器编号。</li><li>–no-trunc :不截断输出。<h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3></li><li>exit：容器停止退出</li><li>Ctrl+P+Q：容器不停止退出<h3 id="容器的启动停止和重启"><a href="#容器的启动停止和重启" class="headerlink" title="容器的启动停止和重启"></a>容器的启动停止和重启</h3></li><li>docker start ID/容器名 启动容器</li><li>docker restart ID/容器名 重启容器</li><li>docker stop ID/容器名 停止容器</li><li>docker kill ID/容器名 强制停止容器</li></ul><p>stop和kill的区别：stop是类似于电脑关机，会进行程序的一系列关闭操作<br>kill则类似于直接断电，强制停止容器，不进行一系列程序关闭所需要执行的操作</p><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><ul><li>docker rm -f ID 删除指定ID的容器</li><li>docker rm -f $(docker ps -q)批量删除全部正在运行的容器</li></ul><h3 id="重新进入容器的方法"><a href="#重新进入容器的方法" class="headerlink" title="重新进入容器的方法"></a>重新进入容器的方法</h3><p>docker exec -it ID BashShell 进入正在运行的容器并以命令行交互<br>例如：<code>docker exec -it ID /bin/bash</code></p><p>docker attach ID 重新进入容器</p><p>区别：<br>attach 直接进入容器启动命令的终端，不会启动新的进程<br>exec 是在容器中打开新的终端，并且可以启动新的进程</p><h3 id="从容器中拷贝文件到主机上"><a href="#从容器中拷贝文件到主机上" class="headerlink" title="从容器中拷贝文件到主机上"></a>从容器中拷贝文件到主机上</h3><p>docker cp ID:容器内路径 目标主机路径<br>例如：<code>docker cp ID:/usr /home</code></p><h3 id="docker-commit-提交指定容器副本成为一个新镜像"><a href="#docker-commit-提交指定容器副本成为一个新镜像" class="headerlink" title="docker commit 提交指定容器副本成为一个新镜像"></a>docker commit 提交指定容器副本成为一个新镜像</h3><pre><code>docker commit -m=“提交的描述信息” -a=“作者” 容器ID 要创建的目标镜像名:[标签名]</code></pre><p>应用场景：当我们从hub上下载的镜像在本地成功运行后，对其中的内容进行了修改，例如配置参数等，当完成我们的修改后，可以使用docker commit命令，为这个修改后的容器生成一个新的镜像，从而当我们运行这个镜像时，里面的内容就是我们修改好的。</p><h3 id="容器相关细节命令"><a href="#容器相关细节命令" class="headerlink" title="容器相关细节命令"></a>容器相关细节命令</h3><pre><code>docker logs -f -t –tail ID 查看容器日志</code></pre><p>参数说明：</p><ul><li>-t 是加入时间戳</li><li>-f 跟随最新的日志打印</li><li>–tail 数字 显示最后多少条</li></ul><p>docker top ID 查看容器内进程</p><p>docker inspect ID 查看容器内部细节（JSON形式表示）</p><h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><p>容器数据卷是为了持久化容器中的数据而设计的，数据卷是完全独立于容器的生命周期，不会因为容器的删除而消失。</p><p>数据卷存在于宿主机中，独立于容器，和容器的生命周期是分离的，数据卷存在于宿主机的文件系统中，数据卷可以目录也可以是文件，容器可以利用数据卷与宿主机进行数据共享，实现了容器间的数据共享和交换。</p><p>数据卷的特点：</p><ol><li>容器启动的时候初始化的，如果容器使用的镜像包含了数据，这些数据也会拷贝到数据卷中。</li><li>容器对数据卷的修改是及时进行的。</li><li>数据卷的变化不会影响镜像的更新。数据卷是独立于联合文件系统，镜像是基于联合文件系统。镜像与数据卷之间不会有相互影响。</li><li>数据卷是宿主机中的一个目录，与容器生命周期隔离。<h3 id="命令添加"><a href="#命令添加" class="headerlink" title="命令添加"></a>命令添加</h3>使用-v可以挂载一个本地的目录到容器中作为数据卷。<br> docker run -it -v /宿主机绝对路径目录:/容器内目录 镜像名</li></ol><p>使用-v运行的容器会在宿主机和容器内对应位置创建文件目录，此时若使用docker inspect命令则可以看到，两个目录已经成功连接、挂载并且同时具有读写权限，此时的容器和宿主机中的对应目录是数据共享的，并且在容器停止后，数据依然共享，且在容器重新启动后数据仍保持一致。</p><p>可以为数据卷添加权限 <code>docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名</code> （ro表示Read-Only）此时的数据卷在容器中只能查看，不能修改。在宿主机中则可以修改。</p><h3 id="DockerFile添加"><a href="#DockerFile添加" class="headerlink" title="DockerFile添加"></a>DockerFile添加</h3><p>可在Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷</p><p>即在DockerFile中添加如下指令：</p><pre><code>VOLUME[&quot;/dataVolumeContainer&quot;,&quot;/dataVolumeContainer2&quot;,&quot;/dataVolumeContainer3&quot;]</code></pre><p>例如：</p><pre><code># volume testFROM centosVOLUME [&quot;/dataVolumeContainer1&quot;,&quot;/dataVolumeContainer2&quot;]CMD echo &quot;finished,--------success1&quot;CMD /bin/bash</code></pre><p>在写好dockerfile文件后，则可以使用docker build命令来生成镜像，执行命令如下：</p><p><code>docker build -f /mydocker/dockerfile -t xxx/centos .</code>（‘.’表示当前目录下）<br>-f:指定dockerfile文件的位置</p><p>-t:生成的镜像命名空间</p><p>此时就生成了一个名为xxx/centos的镜像，运行后就能通过docker inspect命令查看容器的数据卷对应的宿主机目录。</p><blockquote><p>注意：Docker挂载主机目录Docker访问出现cannot open directory .: Permission denied</p><p>解决办法：在挂载目录后多加一个–privileged=true参数即可</p></blockquote><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器。<br>数据卷容器挂载了一个本地目录，其他容器连接这个容器来实现数据的共享（数据地址的拷贝）。</p><p>首先需要一个父容器作为数据卷容器</p><pre><code>docker run -it --name dc01 xxx/centos</code></pre><p>再使用–volumes-from命令则使得子容器继承自父容器</p><pre><code>docker run -it --name dc02 --volumes-from dc01 xxx/centos</code></pre><p>此时父容器dc01和子容器dc02中的数据就共享了，且所有修改都能同步。<br>即使删除任意一个父容器或子容器，数据也仍然共享。</p><p>结论：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止</p><h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><p>Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。</p><h3 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h3><ol><li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li><li>指令按照从上到下，顺序执行</li><li>#表示注释</li><li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li></ol><h3 id="执行大致流程"><a href="#执行大致流程" class="headerlink" title="执行大致流程"></a>执行大致流程</h3><ol><li>docker从基础镜像运行一个容器</li><li>执行一条指令并对容器作出修改</li><li>执行类似docker commit的操作提交一个新的镜像层</li><li>docker再基于刚提交的镜像运行一个新容器</li><li>执行dockerfile中的下一条指令直到所有指令都执行完成</li></ol><h3 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h3><ul><li>FROM：基础镜像，当前新镜像是基于哪个镜像的</li><li>MAINTAINER：镜像维护者的姓名和邮箱地址</li><li>RUN：容器构建时需要运行的命令</li><li>EXPOSE：当前容器对外暴露出的端口</li><li>WORKDIR：指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</li><li>ENV：用来在构建镜像过程中设置环境变量</li><li>ADD：将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</li><li>COPY：类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置</li><li>VOLUME：容器数据卷，用于数据保存和持久化工作</li><li>CMD：指定一个容器启动时要运行的命令；Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换</li><li>ENTRYPOINT：指定一个容器启动时要运行的命令；ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数</li><li>ONBUILD：当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</li></ul><h3 id="dockerfile案例"><a href="#dockerfile案例" class="headerlink" title="dockerfile案例"></a>dockerfile案例</h3><p>自定义镜像mycentos</p><pre><code>FROM centos  MAINTAINER zzyy&lt;zzyy167@126.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo &quot;success--------------ok&quot;CMD /bin/bash </code></pre><p>自定义镜像Tomcat9</p><pre><code>FROM centosMAINTAINERzzyy&lt;zzyybs@126.com&gt;#把宿主机当前上下文的c.txt拷贝到容器/usr/local/路径下COPY c.txt /usr/local/cincontainer.txt#把java与tomcat添加到容器中ADD jdk-8u171-linux-x64.tar.gz /usr/local/ADD apache-tomcat-9.0.8.tar.gz /usr/local/#安装vim编辑器RUN yum -y install vim#设置工作访问时候的WORKDIR路径，登录落脚点ENV MYPATH /usr/localWORKDIR $MYPATH#配置java与tomcat环境变量ENV JAVA_HOME /usr/local/jdk1.8.0_171ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.8ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.8ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin#容器运行时监听的端口EXPOSE  8080#启动时运行tomcat#ENTRYPOINT [&quot;/usr/local/apache-tomcat-9.0.8/bin/startup.sh&quot; ]#CMD [&quot;/usr/local/apache-tomcat-9.0.8/bin/catalina.sh&quot;,&quot;run&quot;]CMD /usr/local/apache-tomcat-9.0.8/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.8/bin/logs/catalina.out</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段</p><ul><li>Dockerfile是软件的原材料</li><li>Docker镜像是软件的交付品</li><li>Docker容器则可以认为是软件的运行态。</li></ul><p>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</p><ol><li>Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</li><li>Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时，会真正开始提供服务;</li><li>Docker容器，容器是直接提供服务的。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;帮助相关&quot;&gt;&lt;a href=&quot;#帮助相关&quot; class=&quot;headerlink&quot; title=&quot;帮助相关&quot;&gt;&lt;/a&gt;帮助相关&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;docker –help 可以查看docker的所有命令（注意单词全拼的参数前都是两个‘-’号）&lt;/li&gt;
&lt;li&gt;docker info 查看docker信息&lt;/li&gt;
&lt;li&gt;docker version 查看docker版本号&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Docker" scheme="Alexaccele.github.io.git/categories/Docker/"/>
    
    
      <category term="Docker" scheme="Alexaccele.github.io.git/tags/Docker/"/>
    
      <category term="命令总结" scheme="Alexaccele.github.io.git/tags/%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>装饰者模式</title>
    <link href="Alexaccele.github.io.git/2018/12/01/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>Alexaccele.github.io.git/2018/12/01/装饰者模式/</id>
    <published>2018-12-01T08:33:47.000Z</published>
    <updated>2020-04-16T08:29:12.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><blockquote><p>装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例</p></blockquote><p>动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。<br><a id="more"></a></p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ul><li>类应该对扩展开放，对修改关闭。</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>这里我们采用一个制作饮料的过程来介绍装饰者模式，我们先来分析一下在饮料制作的过程中有哪些东西是经常变动的，比如饮料是在牛奶里面加巧克力，蜂蜜等等，也有可能是往红茶中添加柠檬之类的，诸如此类，这样如果我们在设计基础饮料时添加太多的配料属性的话，后面如果我们想要更灵活地添加新的配料就很麻烦了。</p><p>我们采用装饰者模式，所有的如牛奶，红茶等等这一类主原料，全部继承于一个抽象的饮料类，然后所有的配料再继承于一个抽象的配料类，而抽象的配料类也同时继承抽象的饮料类。这里的主原料则是一个被装饰者，而配料则是装饰者。</p><p>例如：主原料的基础抽象类Beverage(饮料)</p><pre><code>/** * 饮料类 * 装饰者模式中的被装饰者基类 * */public abstract class Beverage {    String description = &quot;Unknown Beverage&quot;;    public String getDescription() {        return description;    }    public abstract double cost();}</code></pre><p>然后是配料类的抽象类CondimentDecorator，注意装饰者类需要继承被装饰者的基类或接口</p><pre><code>/** * 装饰者模式中的装饰者的抽象基类 * */public abstract class CondimentDecorator extends Beverage {    public abstract String getDescription();}</code></pre><p>一个被装饰者类</p><pre><code>/** * 具体的被装饰者实现类 * 浓缩咖啡Espresso * */public class Espresso extends Beverage {    public Espresso() {        description = &quot;Espresso&quot;;    }    @Override    public double cost() {        return 1.99;    }}</code></pre><p>被装饰者类</p><pre><code>/** * 具体的被装饰者实现类 * */public class HouseBlend extends Beverage {    public HouseBlend() {        description = &quot;House Blend Coffe&quot;;    }    @Override    public double cost() {        return 0.8;    }}</code></pre><p>具体的装饰者类，注意这里继承了装饰者的基类，而这个基类也继承了被装饰者基类，故装饰者类需要继承被装饰者类或实现接口；并且在装饰者类中需要持有被装饰者对象实例。</p><pre><code>/** * 装饰者类 * 摩卡 * */public class Mocha extends CondimentDecorator {    Beverage beverage;    public Mocha(Beverage beverage) {        this.beverage = beverage;    }    @Override    public String getDescription() {        return beverage.getDescription() + &quot;, Mocha&quot;;    }    @Override    public double cost() {        return 0.2 + beverage.cost();    }}/** * 装饰类 * 巧克力 * @author 37111 * */public class Chocolate extends CondimentDecorator {    Beverage beverage;    public Chocolate(Beverage beverage) {        this.beverage = beverage;    }    @Override    public String getDescription() {        return beverage.getDescription() + &quot;,chocolate&quot;;    }    @Override    public double cost() {        return 0.5 + beverage.cost();    }}</code></pre><h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><pre><code>public class Test {    public static void main(String[] args) {        Beverage b1 = new Espresso();        b1 = new Mocha(b1);        b1 = new Chocolate(b1);        System.out.println(b1.getDescription() + &quot;$&quot; + b1.cost());        Beverage b2 = new HouseBlend();        b2 = new Chocolate(b2);        System.out.println(b2.getDescription() + &quot;$&quot; + b2.cost());    }}</code></pre><p>结果：</p><pre><code>Espresso, Mocha,chocolate$2.69House Blend Coffe,chocolate$1.3</code></pre><p>这里我们可以看到使用装饰者模式的好处，当需要添加更多的配料时，只需要再写相应的继承了被装饰者基类的配料类，并且当我们修改任意的配料类的时候，所有的结果也就跟着一起修改了，这样也就实现了类之间的解耦合。</p><h2 id="实际中的应用"><a href="#实际中的应用" class="headerlink" title="实际中的应用"></a>实际中的应用</h2><p>在java的API中使用到装饰者模式的地方有很多，java的I/O流中就使用了装饰者模式BufferedInputStream及LineNumberInputStream都扩展自FilterInputStream，而FilterInputStream是一个抽象的装饰类。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;装饰者模式&quot;&gt;&lt;a href=&quot;#装饰者模式&quot; class=&quot;headerlink&quot; title=&quot;装饰者模式&quot;&gt;&lt;/a&gt;装饰者模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="Alexaccele.github.io.git/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="Alexaccele.github.io.git/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="Alexaccele.github.io.git/2018/12/01/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>Alexaccele.github.io.git/2018/12/01/观察者模式/</id>
    <published>2018-12-01T08:33:10.000Z</published>
    <updated>2020-04-16T08:29:12.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><blockquote><p>定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。<br><a id="more"></a><br>这个模式很好理解，就是多个观察者类观察一个具体的主题，当这个主题改变时，所有的观察者就都知道了这一改变，当某个观察者不再观察这个主题时，则不会注意到这个改变。例如我们生活中的订阅或关注，当你订阅了某个杂志或者关注了某个公众号后，当这个公众号有内容更新，即推送信息时，就会通知你，此时一个公众号就是一个主题，每个用户就是观察者。当你不再关注某个公众号时，则不会再通知你该公众号的相关文章。</p></blockquote><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>这里给出一个案例代码，这是一个对天气实时监控的模拟，当空气中环境变化时，展示板中的内容就会更新，不同的展示板可能可以展示不同的信息，这里只给出一个实例。</p><p>主题：在主题中需要有相应的注册观察者，删除观察者，通知观察者的方法</p><pre><code>/** * 观察者模式中的主题 * */public interface Subject {    /**     * 用于注册观察者     * @param o     */    public void registerObserver(Observer o);    /**     * 用于删除观察者     * @param o     */    public void removeObserver(Observer o);    /**     * 用于通知所有的观察者     */    public void notifyObserver();}</code></pre><p>观察者：</p><pre><code>/** * 观察者 * */public interface Observer {    public void update(float temp,float humidity,float pressure);}</code></pre><p>一个展示板的基础接口：</p><pre><code>public interface DisplayElement {    public void display();}</code></pre><p>具体的主题：</p><pre><code>/** * 一个具体的主题，当发生变化则会通知所有观察者 * */public class WeatherData implements Subject {    private ArrayList observers;    private float temp,humidity,pressure;    public WeatherData() {        observers = new ArrayList&lt;&gt;();    }    @Override    public void registerObserver(Observer o) {        observers.add(o);    }    @Override    public void removeObserver(Observer o) {        int i = observers.indexOf(o);        if(i &gt;= 0)            observers.remove(i);    }    @Override    public void notifyObserver() {        for(int i=0;i&lt;observers.size();i++) {            Observer o = (Observer) observers.get(i);            o.update(temp, humidity, pressure);        }    }    /**     * 当数据更新时调用，用以通知所有的观察者     */    public void measurementsChanged() {        notifyObserver();    }    public void setMeasurements(float temp, float humidity, float pressure) {        this.temp = temp;        this.humidity = humidity;        this.pressure = pressure;        measurementsChanged();    }    //其他方法}</code></pre><p>具体的观察者：</p><pre><code>/** * 一个具体的观察者 * */public class CurrentConditionsDisplay implements Observer,DisplayElement{    private float temp;    private float humidity;    private Subject weatherData;    public CurrentConditionsDisplay(Subject weatherData) {        this.weatherData = weatherData;        weatherData.registerObserver(this);    }    @Override    public void display() {        System.out.println(&quot;Current conditions: &quot; + temp                + &quot;F degrees and &quot; + humidity + &quot;% humidity&quot;);    }    @Override    public void update(float temp, float humidity, float pressure) {        this.temp = temp;        this.humidity = humidity;        display();    }}</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>public class Test {    public static void main(String[] args) {        WeatherData weatherData = new WeatherData();        CurrentConditionsDisplay display = new CurrentConditionsDisplay(weatherData);        weatherData.setMeasurements(80, 65, 30.4f);        weatherData.setMeasurements(83, 75, 29.4f);        weatherData.setMeasurements(81, 68, 31.4f);    }}</code></pre><p>结果：</p><pre><code>Current conditions: 80.0F degrees and 65.0% humidityCurrent conditions: 83.0F degrees and 75.0% humidityCurrent conditions: 81.0F degrees and 68.0% humidity</code></pre><p>这样就实现了当某个主题发生变化时，观察者就能够知道这一变化，通过注册观察者能够实现添加订阅功能，而删除观察者则可以实现取消关注/订阅等功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;观察者模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="Alexaccele.github.io.git/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="Alexaccele.github.io.git/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="Alexaccele.github.io.git/2018/11/20/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>Alexaccele.github.io.git/2018/11/20/策略模式/</id>
    <published>2018-11-20T05:16:53.000Z</published>
    <updated>2020-04-16T08:29:12.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><blockquote><p>策略模式：定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p></blockquote><a id="more"></a><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>设计原则：</p><ul><li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li><li>针对接口编程，而不是针对实现编程。即不需要知道实现细节，只根据接口相关信息编程</li><li>多用组合，少用继承。</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>首先根据面向对象的思想要设计一系列鸭子时，我们会先创建好一个Duck基类，然后在这个基类中添加每个鸭子都会有的行为，例如swim()/quack()/fly()等等行为，于是我们开始给每个子类重写对应的方法，此时若要再添加行为时，我们不仅需要在基类中添加，还要为每个子类添加重写，又或者说是某些子类并不具有基类的全部行为，这时我们可能又要再去修改基类。无论是哪种情况都增加了我们维护和更新功能的负担，策略模式则可以为我们提供一种解决方案，提高代码的重用性。</p><p>我们尝试着把一些变化的行为分离出来，例如quack()和fly()<br>首先是这两个对应方法的接口</p><h3 id="分离行为"><a href="#分离行为" class="headerlink" title="分离行为"></a>分离行为</h3><p>quack行为的接口：</p><pre><code>public interface QuackBehavior {    void quack();}</code></pre><p>fly行为的接口：</p><pre><code>public interface FlyBehavior {    void fly();}</code></pre><h3 id="根据行为的不同进行实现"><a href="#根据行为的不同进行实现" class="headerlink" title="根据行为的不同进行实现"></a>根据行为的不同进行实现</h3><p>在完成了变化行为的分离之后，我们可以针对具体的不同行为提供不同的实现<br>例如，fly的不同行为可能有不能飞和用翅膀飞两种</p><p>用翅膀飞：</p><pre><code>public class FlyWithWings implements FlyBehavior {    @Override    public void fly() {        System.out.println(&quot;fly with wings&quot;);    }}</code></pre><p>不能飞：</p><pre><code>public class FlyNoWay implements FlyBehavior {    @Override    public void fly() {        System.out.println(&quot;can&apos;t fly&quot;);    }}</code></pre><p>以及quack行为</p><pre><code>public class Quack implements QuackBehavior {    @Override    public void quack() {        System.out.println(&quot;quack quack quack&quot;);    }}</code></pre><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><p>我们来完善以上提到的所有类和接口等<br>首先是我们的Duck基类</p><pre><code>public abstract class Duck {    FlyBehavior flyBehavior;    QuackBehavior quackBehavior;    public Duck() {    }    public abstract void display();    public void performQuack() {        quackBehavior.quack();    }    public void performFly() {        flyBehavior.fly();    }    public void swim() {        System.out.println(&quot;all duck can swim&quot;);    }}</code></pre><p>注意在Duck基类中，有为行为接口类型声明的两个引用变量。</p><p>具体子类RubberDuck表示橡胶鸭</p><pre><code>public class RubberDuck extends Duck {    public RubberDuck() {        quackBehavior = new Quack();        flyBehavior = new FlyNoWay();    }    @Override    public void display() {        System.out.println(&quot;a rubber duck&quot;);    }}</code></pre><p>具体子类MallardDuck表示野鸭</p><pre><code>public class MallardDuck extends Duck {    public MallardDuck() {        flyBehavior = new FlyWithWings();        quackBehavior = new Quack();    }    @Override    public void display() {        System.out.println(&quot;a mallard duck&quot;);    }}</code></pre><p>然后我们编写一个测试类Test</p><pre><code>public class Test {    public static void main(String[] args) {        Duck duck = new RubberDuck();        duck.performFly();        duck.performQuack();        duck.display();        duck.swim();        System.out.println(&quot;------------&quot;);        Duck duck2 = new MallardDuck();        duck2.performFly();        duck2.performQuack();        duck2.display();        duck2.swim();    }}</code></pre><p>于是我们可以看到运行结果：</p><pre><code>can&apos;t flyquack quack quacka rubber duckall duck can swim------------fly with wingsquack quack quacka mallard duckall duck can swim</code></pre><p>这里可以看出我们实现了不同行为的分离，并且在使用时都是使用的基类以及基类的方法，在使用时与具体的实现相分离了，由此也可以看到策略模式的魅力。</p><h3 id="动态设定行为"><a href="#动态设定行为" class="headerlink" title="动态设定行为"></a>动态设定行为</h3><p>我们还可以对现在的代码进行进一步的完善，我们可以为Duck基类添加不同行为的set()方法，以实现动态的行为设定</p><p>尽管橡皮鸭不会飞，但我们可以通过将它抛在空中，于是它也有了“fly”的能力,因此我们实现一个新的fly行为</p><pre><code>public class FlyWithThrow implements FlyBehavior {    @Override    public void fly() {        System.out.println(&quot;fly with throw&quot;);    }}</code></pre><p>测试：</p><pre><code>public class Test {    public static void main(String[] args) {        Duck duck = new RubberDuck();        duck.performFly();        duck.setFlyBehavior(new FlyWithThrow());        duck.performFly();        duck.performQuack();        duck.display();        duck.swim();        System.out.println(&quot;------------&quot;);        Duck duck2 = new MallardDuck();        duck2.performFly();        duck2.performQuack();        duck2.display();        duck2.swim();    }}</code></pre><p>结果：</p><pre><code>can&apos;t flyfly with throwquack quack quacka rubber duckall duck can swim------------fly with wingsquack quack quacka mallard duckall duck can swim</code></pre><p>可以看到原本不会飞的橡皮鸭通过我们新的行为实现，也能够通过特定的方式进行”fly”了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>让我们回过头来再看看策略模式的定义</p><blockquote><p>策略模式：定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p></blockquote><p>再看看我们的案例，首先分离出的两种行为fly和quack就是两个算法族，然后其中各自的具体实现就是封装，同一个算法族中的算法可以相互替换，因为接口相同，替换之后也就有了不一样的行为，这样的策略模式使得我们的代码有了更好的重用性。</p><p>例如，当我们再需要添加新的鸭子时，可以根据它的不同行为选择不同的算法族，而不用去修改原本已经写好的基类和子类。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;策略模式：定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="Alexaccele.github.io.git/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="Alexaccele.github.io.git/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统——调度算法</title>
    <link href="Alexaccele.github.io.git/2018/11/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>Alexaccele.github.io.git/2018/11/06/操作系统——调度算法/</id>
    <published>2018-11-06T09:28:27.000Z</published>
    <updated>2020-04-16T08:29:12.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统——调度算法"><a href="#操作系统——调度算法" class="headerlink" title="操作系统——调度算法"></a>操作系统——调度算法</h1><h2 id="作业调度算法"><a href="#作业调度算法" class="headerlink" title="作业调度算法"></a>作业调度算法</h2><h3 id="先来先服务调度算法（first-come-first-served-FCFS）"><a href="#先来先服务调度算法（first-come-first-served-FCFS）" class="headerlink" title="先来先服务调度算法（first-come first-served,FCFS）"></a>先来先服务调度算法（first-come first-served,FCFS）</h3><p>FCFS是最简单的调度算法，既可以用于作业调度，也可以用于进程调度，系统将按照作业到达的先后次序来进行调度。</p><h3 id="短作业优先调度算法（short-job-first-SJF）"><a href="#短作业优先调度算法（short-job-first-SJF）" class="headerlink" title="短作业优先调度算法（short job first,SJF）"></a>短作业优先调度算法（short job first,SJF）</h3><p>SJF算法是以作业的长短来计算优先级，作业越短，优先级越高。作业的长短是以作业所要求的运行时间来衡量的。可以分别用于作业调度和进程调度。</p><a id="more"></a><p>缺点：</p><ol><li>必须预知作业的运行时间</li><li>对长作业很不利，长作业的周转时间会明显地增长。可能使长作业等待时间过长，出现饥饿现象</li><li>在采用SJF算法时，无法实现人机交互</li><li>不能保证紧迫性作业能得到及时处理</li></ol><h3 id="优先级调度算法（priority-scheduling-algorithm-PSA）"><a href="#优先级调度算法（priority-scheduling-algorithm-PSA）" class="headerlink" title="优先级调度算法（priority-scheduling algorithm,PSA）"></a>优先级调度算法（priority-scheduling algorithm,PSA）</h3><p>基于作业的紧迫程度的算法，由外部赋予作业相应的优先级，根据优先级进行调度，可以保证紧迫性作业优先运行。可以分别用于作业调度和进程调度。</p><h3 id="高响应比优先调度算法（Highest-Response-Ratio-Next-HRRN）"><a href="#高响应比优先调度算法（Highest-Response-Ratio-Next-HRRN）" class="headerlink" title="高响应比优先调度算法（Highest Response Ratio Next,HRRN）"></a>高响应比优先调度算法（Highest Response Ratio Next,HRRN）</h3><p>采用一种动态的优先级，优先级随着等待时间的延长而增加，这将使长作业的优先级在等待期间不断地增加，等到足够的时间后，就有机会获得处理机。<br><code>优先级 = （等待时间 + 要求服务时间） / 要求服务时间</code></p><p>由于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先级又相当于响应比Rp</p><p><code>Rp = （等待时间 + 要求服务时间） / 要求服务时间 = 响应时间 / 要求服务时间</code></p><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><h3 id="时间片轮转调度算法（round-robin-RP）"><a href="#时间片轮转调度算法（round-robin-RP）" class="headerlink" title="时间片轮转调度算法（round robin,RP）"></a>时间片轮转调度算法（round robin,RP）</h3><p>原理：<br>在轮转(RR)法中,系统根据 FCFS 策略,将所有的就绪进程排成一个就绪队列,并可设置每隔一定时间间隔(如30 ms)即产生一次中断,激活系统中的进程调度程序,完成一次调度,将CPU分配给队首进程,令其执行。当该进程的时间片耗尽或运行完毕时,系统再次将CPU分配给新的队首进程(或新到达的紧迫进程)。由此,可保证就绪队列中的所有进程在一个确定的时间段内,都能够获得一次CPU 执行。</p><p>切换时机：<br>在RR调度算法中,应在何时进行进程的切换,可分为两种情况: </p><ol><li>若一个时间片尚未用完,正在运行的进程便已经完成,就立即激活调度程序,将它从就绪队列中删除,再调度就绪队列中队首的进程运行,并启动一个新的时间片。</li><li>在一个时间片用完时,计时器中断处理程序被激活。 如果进程尚未运行完毕,调度程序将把它送往就绪队列的末尾。</li></ol><p>时间片大小的确定：<br>在轮转算法中,时间片的大小对系统性能有很大的影响。 若选择很小的时间片,将有<br>利于短作业,因为它能在该时间片内完成。 但时间片小,意味着会频繁地执行进程调度和<br>进程上下文的切换,这无疑会增加系统的开销。 反之,若时间片选择得太长,且为使每个<br>进程都能在一个时间片内完成,RR算法便退化为FCFS算法,无法满足短作业和交互式用<br>户的需求。 一个较为可取的时间片大小是略大于一次典型的交互所需要的时间,使大多数<br>交互式进程能在一个时间片内完成,从而可以获得很小的响应时间。</p><h3 id="多级反馈队列调度算法（multileved-feedback-queue）"><a href="#多级反馈队列调度算法（multileved-feedback-queue）" class="headerlink" title="多级反馈队列调度算法（multileved feedback queue）"></a>多级反馈队列调度算法（multileved feedback queue）</h3><p>前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的过程如下所述。</p><ol><li>应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。</li><li><p>当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。</p></li><li><p>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统——调度算法&quot;&gt;&lt;a href=&quot;#操作系统——调度算法&quot; class=&quot;headerlink&quot; title=&quot;操作系统——调度算法&quot;&gt;&lt;/a&gt;操作系统——调度算法&lt;/h1&gt;&lt;h2 id=&quot;作业调度算法&quot;&gt;&lt;a href=&quot;#作业调度算法&quot; class=&quot;headerlink&quot; title=&quot;作业调度算法&quot;&gt;&lt;/a&gt;作业调度算法&lt;/h2&gt;&lt;h3 id=&quot;先来先服务调度算法（first-come-first-served-FCFS）&quot;&gt;&lt;a href=&quot;#先来先服务调度算法（first-come-first-served-FCFS）&quot; class=&quot;headerlink&quot; title=&quot;先来先服务调度算法（first-come first-served,FCFS）&quot;&gt;&lt;/a&gt;先来先服务调度算法（first-come first-served,FCFS）&lt;/h3&gt;&lt;p&gt;FCFS是最简单的调度算法，既可以用于作业调度，也可以用于进程调度，系统将按照作业到达的先后次序来进行调度。&lt;/p&gt;
&lt;h3 id=&quot;短作业优先调度算法（short-job-first-SJF）&quot;&gt;&lt;a href=&quot;#短作业优先调度算法（short-job-first-SJF）&quot; class=&quot;headerlink&quot; title=&quot;短作业优先调度算法（short job first,SJF）&quot;&gt;&lt;/a&gt;短作业优先调度算法（short job first,SJF）&lt;/h3&gt;&lt;p&gt;SJF算法是以作业的长短来计算优先级，作业越短，优先级越高。作业的长短是以作业所要求的运行时间来衡量的。可以分别用于作业调度和进程调度。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="Alexaccele.github.io.git/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="Alexaccele.github.io.git/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统——死锁</title>
    <link href="Alexaccele.github.io.git/2018/11/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E6%AD%BB%E9%94%81/"/>
    <id>Alexaccele.github.io.git/2018/11/06/操作系统——死锁/</id>
    <published>2018-11-06T09:28:03.000Z</published>
    <updated>2020-04-16T08:29:12.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>在一组进程发生死锁的情况下,这组死锁进程中的每一个进程,都在等待另一个死锁<br>进程所占有的资源。 或者说每个进程所等待的事件是该组中其它进程释放所占有的资源。<br>但由于所有这些进程已都无法运行,因此它们谁也不能释放资源,致使没有任何一个进程<br>可被唤醒。 这样这组进程只能无限期地等待下去。 由此可以给死锁做出如下的定义:</p><blockquote><p>如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件,<br>那么该组进程是死锁的(Deadlock).</p></blockquote><h2 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h2><ol><li>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li><li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li><li>环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。<a id="more"></a><h2 id="处理死锁的方法"><a href="#处理死锁的方法" class="headerlink" title="处理死锁的方法"></a>处理死锁的方法</h2></li></ol><h3 id="1-预防死锁"><a href="#1-预防死锁" class="headerlink" title="1. 预防死锁"></a>1. 预防死锁</h3><h4 id="破坏“请求与保持”条件"><a href="#破坏“请求与保持”条件" class="headerlink" title="破坏“请求与保持”条件"></a>破坏“请求与保持”条件</h4><p>在采用这种方法时，系统规定所有进程在开始运行之前，都必须一次性的申请其在整个运行过程所需的全部资源。此时，若系统有足够的资源分配给某进程，便可把其需要的所有资源分配给进程，这样，该进程在整个运行期间便不会再提出资源要求，从而破坏了请求条件。但在分配资源时，只要有一种资源不能满足某进程的要求，即使其它所需各资源都空闲，也不分配给该进程，而让该进程等待。由于在该进程的等待期间，它并未占用任何资源，因而也破坏了保持条件，从而避免发生死锁。</p><p>缺点：首先表现为资源被严重浪费，因为一个进程是一次性地获得其整个运行过程中所需的全部资源的，且独占资源，其中可能有些资源很少用，甚至在整个运行期间都未使用，这就严重的恶化了系统资源的利用率；其次是使进程延迟运行，仅当进程在获得了其所需的全部资源后，才能开始运行，但可能因有些资源已长期被其它进程占用而使等待该资源的进程迟迟不能运行。</p><h4 id="破坏“不剥夺”条件"><a href="#破坏“不剥夺”条件" class="headerlink" title="破坏“不剥夺”条件"></a>破坏“不剥夺”条件</h4><p>在采用这种方法时系统规定，进程是逐个地提出对资源的要求的。当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即满足时，必须释放它已经保持了的所有资源，待以后需要时再重新申请。这意味着某一进程已经占有的资源，在运行过程中会被占时释放掉，也可认为是被剥夺了，从而破坏了“不剥夺”条件。</p><h4 id="破坏“环路等待”条件"><a href="#破坏“环路等待”条件" class="headerlink" title="破坏“环路等待”条件"></a>破坏“环路等待”条件</h4><p>这种方法中规定，系统将所有资源按类型进行线性排队，并赋予不同的序号。例如，令输入机的序号为1，打印机的序号为2，磁带机为3，磁盘为4.所有进程对资源的请求必须严格按照资源序号递增的次序提出，这样，在所形成的资源分配图中，不可能再出现环路，因而破坏了“环路等待”条件。</p><h3 id="2-避免死锁"><a href="#2-避免死锁" class="headerlink" title="2. 避免死锁"></a>2. 避免死锁</h3><p>利用银行家算法避免死锁：每一个新进程在进入系统时，必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才将资源分配给进程，否则让进程等待。</p><h3 id="3-检测死锁"><a href="#3-检测死锁" class="headerlink" title="3. 检测死锁"></a>3. 检测死锁</h3><p>资源分配图（Resource Allocation Graph）</p><p><img src="https://i.imgur.com/EmAOhkH.png" alt></p><p>如上图， 用圆圈代表一个进程，用框代表一类资源。由于一种类型的资源可能有多个，用框中的一个点代表一类资源中的一个资源。从进程到资源的有向边叫请求边，表示该进程申请一个单位的该类资源；从资源到进程的边叫分配边，表示该类资源已经有一个资源被分配给了该进程。</p><p>死锁定理：<br>可以通过将资源分配图简化的方法来检测系统状态  S  是否为死锁状态。简化方法如下：</p><p>（1）、在资源分配图中，找到既不阻塞又不是孤点的进程 Pi （即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量）。消去它所有的请求边和分配边，使之成为孤立的结点。在这里要注意一个问题，判断某种资源是否有空闲，应该用它的资源数量减去它在资源分配图中的出度。</p><p>（2）、进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可以变为非阻塞进程。根据（1）中的方法进行一系列简化后，若能消去图中所有的边，则称该图是可完全简化的。<br>S为死锁的条件是：当且仅当 S 状态的资源分配图是不可完全简化的，该条件为死锁定理。</p><h3 id="4-解除死锁"><a href="#4-解除死锁" class="headerlink" title="4. 解除死锁"></a>4. 解除死锁</h3><p>一旦检测出死锁，就应立即采取相应的措施，以解除死锁。死锁解除的主要方法有：</p><p>（1）、资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</p><p>（2）、撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</p><p>（3）、进程回退法。让一（或多）个进程回退足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h1&gt;&lt;p&gt;在一组进程发生死锁的情况下,这组死锁进程中的每一个进程,都在等待另一个死锁&lt;br&gt;进程所占有的资源。 或者说每个进程所等待的事件是该组中其它进程释放所占有的资源。&lt;br&gt;但由于所有这些进程已都无法运行,因此它们谁也不能释放资源,致使没有任何一个进程&lt;br&gt;可被唤醒。 这样这组进程只能无限期地等待下去。 由此可以给死锁做出如下的定义:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件,&lt;br&gt;那么该组进程是死锁的(Deadlock).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;产生死锁的必要条件&quot;&gt;&lt;a href=&quot;#产生死锁的必要条件&quot; class=&quot;headerlink&quot; title=&quot;产生死锁的必要条件&quot;&gt;&lt;/a&gt;产生死锁的必要条件&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。&lt;/li&gt;
&lt;li&gt;请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。&lt;/li&gt;
&lt;li&gt;不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。&lt;/li&gt;
&lt;li&gt;环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。
    
    </summary>
    
      <category term="操作系统" scheme="Alexaccele.github.io.git/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="Alexaccele.github.io.git/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="死锁" scheme="Alexaccele.github.io.git/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>操作系统——进程</title>
    <link href="Alexaccele.github.io.git/2018/11/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B/"/>
    <id>Alexaccele.github.io.git/2018/11/04/操作系统——进程/</id>
    <published>2018-11-04T08:11:40.000Z</published>
    <updated>2020-04-16T08:29:12.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统——进程"><a href="#操作系统——进程" class="headerlink" title="操作系统——进程"></a>操作系统——进程</h1><h2 id="进程的定义与特征"><a href="#进程的定义与特征" class="headerlink" title="进程的定义与特征"></a>进程的定义与特征</h2><p>为了使参与并发执行的每个程序都能够独立地运行，在操作系统中配置了一个专门的数据结构，称为进程控制块（Process Control Block,PCB）。系统利用PCB来描述进程的基本情况和活动过程，进而控制和管理进程。通常称进程实体为进程。<br>创建进程，实质上是创建进程实体中的PCB；<br>撤销进程，实质上是撤销进程的PCB。</p><p>定义：</p><ol><li>进程是程序的一次执行</li><li>进程是可以和别的计算并行执行</li><li>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位<a id="more"></a>特征：</li></ol><ul><li>动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的。</li><li>并发性：任何进程都可以同其他进程一起并发执行。</li><li>独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位。</li><li>异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。</li></ul><h2 id="进程的状态及转换"><a href="#进程的状态及转换" class="headerlink" title="进程的状态及转换"></a>进程的状态及转换</h2><p>进程的几种状态：</p><ol><li>新建状态(New)：新创建了一个线程对象。</li><li>就绪状态(Runnable)：线程对象创建后，其他线程调用了该对象的start()方法。该状态<br>的线程位于“可运行线程池”中，变得可运行，只等待获取CPU的使用权。即在就绪状态的<br>进程除CPU之外，其它的运行所需资源都已全部获得。</li><li>运行状态(Running)：就绪状态的线程获取了CPU，执行程序代码。</li><li>阻塞状态(Blocked)：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。</li><li>死亡状态(Dead)：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li></ol><p>直到线程进入就绪状态，才有机会转到运行状态。</p><p>阻塞的情况分三种：</p><ol start="2"><li>等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线<br>程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用<br>notify()或notifyAll()方法才能被唤醒，</li><li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM<br>会把该线程放入“锁池”中。</li><li>其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该<br>线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕<br>时，线程重新转入就绪状态。</li></ol><p>线程变化的状态转换图如下：</p><p><img src="https://i.imgur.com/O3Du3my.png" alt></p><h2 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h2><p>PCB作为进程实体的一部分，记录了操作系统所需的，用于描述进程的当前情况以及管理进程运行的全部信息，是操作系统中最重要的记录型数据结构。</p><p>PCB的作用是使一个在多道程序环境下不能独立运行的程序（含数据）成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。</p><ol><li>作为独立运行基本单位的标志。</li><li>能实现间断性运行方式。</li><li>提供进程管理所需的信息。</li><li>提供进程调度所需要的信息。</li><li>实现与其他进程的同步与通信。</li></ol><h3 id="进程控制块中的信息"><a href="#进程控制块中的信息" class="headerlink" title="进程控制块中的信息"></a>进程控制块中的信息</h3><ol><li>进程标识符：用于唯一地标识一个进程。</li><li>处理机状态：也称为处理机的上下文，主要是由处理机的各种寄存器中的内容组成的。包括通用寄存器、指令寄存器、程序状态字PSW、用户栈指针。</li><li>进程调度信息：（1）进程状态，指明进程的当前状态；（2）进程优先级，用于描述进程使用处理机的优先级别的一个整数；（3）进程调度所需的其他信息，比如进程已等待CPU的时间总和、进程已执行的时间总和等；（4）事件，是指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因。</li><li>进程控制信息：用于进程控制所必须的信息，（1）程序和数据的地址；（2）进程同步和通信机制；（3）资源清单，在该清单中列出了进程在运行期间所需的全部资源（除CPU外的），还有一张已分配到该进程的资源清单；（4）链接指针，本进程所在队列的下一个进程的PCB的首地址。</li></ol><h3 id="进程控制块的组织方式"><a href="#进程控制块的组织方式" class="headerlink" title="进程控制块的组织方式"></a>进程控制块的组织方式</h3><p>线性方式：将系统中所有的PCB都组织在一张线性表中，将该表的首地址存放在内存的一个专用区域中。</p><p> <img src="https://i.imgur.com/TXLm9Gz.png" alt></p><p>链接方式：把具有相同状态进程的PCB分别通过PCB中的链接字链接成一个队列</p><p> <img src="https://i.imgur.com/W96XROG.png" alt></p><p>索引方式：系统根据所有进程状态的不同，建立几张索引表。</p><p> <img src="https://i.imgur.com/kdAaJny.png" alt></p><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><h3 id="引起创建进程的事件"><a href="#引起创建进程的事件" class="headerlink" title="引起创建进程的事件"></a>引起创建进程的事件</h3><p>导致一个进程去创建另一个进程的典型事件有四类：</p><ol><li>用户登录：在分时系统中，用户在终端键入登录命令后，若成功登录，系统将为该用户建立一个进程，并把它插入到就绪队列中。</li><li>作业调度：在多道批处理系统中，当作业调度程序按一定的算法调度到某些作业时，便将其装入内存，创建进程，并插入到就绪队列中。</li><li>提供服务：当运行中的用户程序提出某种请求后，系统将专门创建一个进程来提供用户所需要的服务。</li><li>应用请求：由用户进程自己创建新进程，以便使新进程以同创建者进程并发运行的方式完成特定任务。</li></ol><h3 id="进程的创建-1"><a href="#进程的创建-1" class="headerlink" title="进程的创建"></a>进程的创建</h3><ol><li><p>申请空白PCB,为新进程申请获得唯一的数字标识符,并从PCB集合中索取一个空白PCB.</p></li><li><p>为新进程分配其运行所需的资源。包括各种物理和逻辑资源,如内存、文件、I/O设备和CPU时间等。这些资源或从操作系统或仅从其父进程获得。新进程对这些资源的需求详情一般也要提前告知操作系统或其父进程。 例如, 为新进程的程序和数据以及用户栈分配必要的内存空间时,操作系统必须知道新进程所需内存的大小: 1 对于批处理作业,其大小可在用户提出创建进程要求时提供;2 若是为应用进程创建子进程,也应是在该进程提出创建进程的请求中给出所需内存的大小;3 对于交互型作业,用户可以不给出内存要求而由系统分配一定的空间;如果新进程要共享某个已在内存的地址空间(即已装入内存的共享段),则必须建立相应的链接。</p></li><li><p>初始化进程控制块(PCB)。PCB的初始化包括: 1 初始化标识信息,将系统分配的标识符和父进程标识符填入新 PCB中;2 初始化处理机状态信息,使程序计数器指向程序的入口地址,使栈指针指向栈顶; 3 初始化处理机控制信息,将进程的状态设置为就绪状态或静止就绪状态,对于优先级,通常是将它设置为最低优先级,除非用户以显式方式提出高优先级要求。</p></li><li><p>如果进程就绪队列能够接纳新进程,便将新进程插入就绪队列。</p></li></ol><h2 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h2><h3 id="引起进程终止的3种事件"><a href="#引起进程终止的3种事件" class="headerlink" title="引起进程终止的3种事件"></a>引起进程终止的3种事件</h3><ul><li><p>正常结束：表示进程的任务已经完成</p></li><li><p>异常结束：是指进程在运行时发生了某种异常事件, 使程序无法继续运行。常见的异常事件有: </p><blockquote><p>1.越界错,这是指程序所访问的存储区,已越出该进程的区域;</p><p>2.保护错,指进程试图去访问一个不允许访问的资源或文件, 或者以不适当的方式进行访问,例如,进程试图去写一个只读文件;</p><p>3.非法指令,指程序试图去执行一条不存在的指令。出现该错误的原因可能是程序错误地转移到数据区,把数据当成了指令;</p><p>4.特权指令错,指用户进程试图去执行一条只允许OS执行的指令;</p><p>5.运行超时,指进程的执行时间超过了指定的最大值; </p><p>6.等待超时,指进程等待某事件的时间超过了规定的最大值;</p><p>7.算术运算错,指进程试图去执行一个被禁止的运算,例如,被0除;</p><p>8.I/0故障,这是指在I/O过程中发生了错误等。</p></blockquote></li></ul><ul><li>外界干预：是指进程应外界的请求而终止运行。这些干预有: <blockquote><p>1.操作员或操作系统干预,指如果系统中发生了某事件,例如,发生了系统死锁, 由操作员或操作系统采取终止某些进程的方式使系统从死锁状态中解救出来;</p><p>2.父进程请求,指当子进程已完成父进程所要求的任务时,父进程可以提出请求结束该子进程;</p><p>3.因父进程终止,指当父进程终止时,它的所有子进程也都应当结束,因此,OS在终止父进程的同时,也将它的所有子孙进程终止。</p></blockquote></li></ul><h3 id="进程的终止过程"><a href="#进程的终止过程" class="headerlink" title="进程的终止过程"></a>进程的终止过程</h3><ol><li><p>根据被终止进程的标识符,从PCB集合中检索出该进程的PCB,从中读出该进程的状态;</p></li><li><p>若被终止进程正处于执行状态,应立即终止该进程的执行,并置调度标志为真,用于指示该进程被终止后应重新进行调度;</p></li><li><p>若该进程还有子孙进程,还应将其所有子孙进程也都予以终止, 以防它们成为不可控的进程;</p></li><li><p>将被终止进程所拥有的全部资源或者归还给其父进程,或者归还给系统;</p></li><li><p>将被终止进程(PCB)从所在队列(或链表)中移出,等待其它程序来搜集信息。</p></li></ol><h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><ul><li><p>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关<br>系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p></li><li><p>有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程<br>间的通信。</p></li><li><p>信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访<br>问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，<br>主要作为进程间以及同一进程内不同线程之间的同步手段。</p></li><li><p>消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标<br>识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限<br>等缺点。</p></li><li><p>信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p></li><li><p>共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共<br>享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其<br>他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，<br>来实现进程间的同步和通信。</p></li><li><p>套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于<br>不同及其间的进程通信。</p></li></ul><h2 id="进程与线程对比"><a href="#进程与线程对比" class="headerlink" title="进程与线程对比"></a>进程与线程对比</h2><ul><li><p>进程是资源分配的最小单位，线程是程序执行的最小单位。</p></li><li><p>进程是系统进行资源分配和调度的一个独立单位.</p></li><li><p>线程是进程的一个实体,是CPU调度和分派的基本单位</p></li><li><p>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</p></li><li><p>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</p></li><li><p>但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</p></li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。<br>同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统——进程&quot;&gt;&lt;a href=&quot;#操作系统——进程&quot; class=&quot;headerlink&quot; title=&quot;操作系统——进程&quot;&gt;&lt;/a&gt;操作系统——进程&lt;/h1&gt;&lt;h2 id=&quot;进程的定义与特征&quot;&gt;&lt;a href=&quot;#进程的定义与特征&quot; class=&quot;headerlink&quot; title=&quot;进程的定义与特征&quot;&gt;&lt;/a&gt;进程的定义与特征&lt;/h2&gt;&lt;p&gt;为了使参与并发执行的每个程序都能够独立地运行，在操作系统中配置了一个专门的数据结构，称为进程控制块（Process Control Block,PCB）。系统利用PCB来描述进程的基本情况和活动过程，进而控制和管理进程。通常称进程实体为进程。&lt;br&gt;创建进程，实质上是创建进程实体中的PCB；&lt;br&gt;撤销进程，实质上是撤销进程的PCB。&lt;/p&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程是程序的一次执行&lt;/li&gt;
&lt;li&gt;进程是可以和别的计算并行执行&lt;/li&gt;
&lt;li&gt;进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位
    
    </summary>
    
      <category term="操作系统" scheme="Alexaccele.github.io.git/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="Alexaccele.github.io.git/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程" scheme="Alexaccele.github.io.git/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域</title>
    <link href="Alexaccele.github.io.git/2018/11/04/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>Alexaccele.github.io.git/2018/11/04/Java内存区域/</id>
    <published>2018-11-04T08:10:31.000Z</published>
    <updated>2020-04-16T08:29:12.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。</p><ol><li>程序计数器 （线程隔离）</li><li>Java虚拟机栈 （线程隔离）</li><li>本地方法栈</li><li>Java堆 （线程共享）</li><li>方法区 （线程共享）</li><li>运行时常量池 （属于方法区的一部分）<a id="more"></a><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2>程序计数器（Program Counter Register）是一块较小的内存空间，是当前线程所执行的字节码的行号指示器。通过计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li></ol><p>在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，是线程私有的。</p><p>是唯一一个在Java虚拟机规范中没有规定任何<code>OutOfMemoryError</code>情况的区域。</p><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>Java虚拟机栈的生命周期与线程相同。<br>Java中每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于<code>存储局部变量表</code>、<code>操作数栈</code>、<code>动态链接</code>、<code>方法出口</code>等信息。每一个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中的入栈到出栈的过程。</p><p><code>局部变量表</code>存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，不一定是对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p><p>64位长度的long和double类型的数据会占用2个局部变量空间（Slot）,其余数据类型值占用1个。</p><p>局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小。</p><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError</code>异常；<br>如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，将会抛出<code>OutOfMemoryError</code>异常。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>作用与虚拟机栈非常相似，虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈为虚拟机使用到的Native方法服务。</p><p>与虚拟机栈相同，也会抛出<code>StackOverflowError</code>异常和<code>OutOfMemoryError</code>异常。</p><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域。此内存区域的唯一目的就是存放对象实例，<strong>几乎所有</strong>的对象实例都在这里分配内存。</p><p>Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。</p><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出<code>OutOfMemoryError</code>异常。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。</p><p>有时方法区也被称为“永久代”（Permanent Generation）。但却并不是真的永久存在。在JDK1.7的HotSpot中，已经把原本放在永久代的字符串常量池移出了。</p><p>该区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</p><p>当方法区无法满足内存分配需求时，将抛出<code>OutOfMemoryError</code>异常。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。编译期生成的各种字面量和符合引用，将在类加载后进入方法区的运行时常量池。</p><p>当常量池无法再申请到内存时会抛出<code>OutOfMemoryError</code>异常。</p><h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，是本机的直接内存（物理内存），当本机的内存不足时，导致动态扩展失败仍然会抛出<code>OutOfMemoryError</code>异常。</p><blockquote><p>本文参考自《深入理解Java虚拟机》第二版</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java内存区域&quot;&gt;&lt;a href=&quot;#Java内存区域&quot; class=&quot;headerlink&quot; title=&quot;Java内存区域&quot;&gt;&lt;/a&gt;Java内存区域&lt;/h1&gt;&lt;p&gt;Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;程序计数器 （线程隔离）&lt;/li&gt;
&lt;li&gt;Java虚拟机栈 （线程隔离）&lt;/li&gt;
&lt;li&gt;本地方法栈&lt;/li&gt;
&lt;li&gt;Java堆 （线程共享）&lt;/li&gt;
&lt;li&gt;方法区 （线程共享）&lt;/li&gt;
&lt;li&gt;运行时常量池 （属于方法区的一部分）
    
    </summary>
    
      <category term="JVM" scheme="Alexaccele.github.io.git/categories/JVM/"/>
    
    
      <category term="JVM" scheme="Alexaccele.github.io.git/tags/JVM/"/>
    
      <category term="内存" scheme="Alexaccele.github.io.git/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>对象存活算法</title>
    <link href="Alexaccele.github.io.git/2018/11/04/%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E7%AE%97%E6%B3%95/"/>
    <id>Alexaccele.github.io.git/2018/11/04/对象存活算法/</id>
    <published>2018-11-04T08:10:11.000Z</published>
    <updated>2020-04-16T08:29:12.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象存活算法"><a href="#对象存活算法" class="headerlink" title="对象存活算法"></a>对象存活算法</h1><p>在Java的垃圾收集器对堆进行回收之前，首先要判断，什么样的对象才是需要回收的对象，而什么样的对象是“存活”的对象。这就需要有一个判断的方法。<br><a id="more"></a></p><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>有一种很简单粗暴的判断方法就是引用计数算法，即给对象中添加一个引用计数器，当出现一个地方引用该对象时，计数器的值就+1；当引用失效时，计数器的值就-1；当任意时刻计数器的值为0时，则判断该对象就不可能在被使用。这种算法实现很简单，且判断效率很高，当有一个问题，这种算法很难解决对象之间相互循环引用的问题，所以在Java虚拟机中并没有采用这种算法。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>可达性分析算法的基本思想就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，所经过的路径称为“引用链（Reference Chain）”,当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p><p>通过这样的可达性分析，即使是两个相互循环引用的对象，也会被判断为不可到达GC Roots，从而判断为不可用对象。</p><p>可作为GC Roots的对象包括以下几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中的引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI(Native方法)引用的对象 </li></ul><h2 id="引用分类"><a href="#引用分类" class="headerlink" title="引用分类"></a>引用分类</h2><h3 id="强引用（Strong-Reference）"><a href="#强引用（Strong-Reference）" class="headerlink" title="强引用（Strong Reference）"></a>强引用（Strong Reference）</h3><p>强引用是指在程序代码之中普遍存在的，类似“<code>Object obj = new Object()</code>” 这类的引用，只要强引用还在，垃圾收集器就永远不会回收掉被引用的对象。</p><h3 id="软引用（Soft-Reference）"><a href="#软引用（Soft-Reference）" class="headerlink" title="软引用（Soft Reference）"></a>软引用（Soft Reference）</h3><p>软引用用于描述一些有用但不必要的对象，在系统将要发生内存溢出前，会把这类引用对象列入垃圾回收的范围，进行第二次回收。</p><h3 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h3><p>被弱引用关联的对象只能生存到下次垃圾收集发生之前。即当垃圾收集器开始工作时，一定会回收掉该类引用的对象。</p><h3 id="虚引用（Phantom-Reference）"><a href="#虚引用（Phantom-Reference）" class="headerlink" title="虚引用（Phantom Reference）"></a>虚引用（Phantom Reference）</h3><p>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p><blockquote><p>本文参考自《深入理解Java虚拟机》第二版</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;对象存活算法&quot;&gt;&lt;a href=&quot;#对象存活算法&quot; class=&quot;headerlink&quot; title=&quot;对象存活算法&quot;&gt;&lt;/a&gt;对象存活算法&lt;/h1&gt;&lt;p&gt;在Java的垃圾收集器对堆进行回收之前，首先要判断，什么样的对象才是需要回收的对象，而什么样的对象是“存活”的对象。这就需要有一个判断的方法。&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="Alexaccele.github.io.git/categories/JVM/"/>
    
    
      <category term="JVM" scheme="Alexaccele.github.io.git/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器</title>
    <link href="Alexaccele.github.io.git/2018/11/04/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>Alexaccele.github.io.git/2018/11/04/垃圾收集器/</id>
    <published>2018-11-04T08:09:48.000Z</published>
    <updated>2020-04-16T08:29:12.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>一张图了解所有垃圾收集器：</p><p><img src="https://i.imgur.com/TlqSyOl.png" alt><br>上图中的收集器两两之间有连线的，则说明可以搭配使用。</p><p>由于markdownpad2不知道怎么回事插入的图片无法显示，如果无法正常查看图片，可以移步到我的CSDN地址查看图片：<a href="https://blog.csdn.net/qq_40995335/article/details/83716798" target="_blank" rel="noopener">https://blog.csdn.net/qq_40995335/article/details/83716798</a><br><a id="more"></a></p><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>单线程的收集器，在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。Serial收集器是虚拟机运行在Client模式下的默认新生代收集器，对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，可以获得最高的单线程收集效率。</p><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>是Serial收集器的多线程版本，是许多虚拟机运行在Server模式下的首选新生代收集器。</p><h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p>目标是达到一个可控制的吞吐量。经常被称为“吞吐量优先”收集器。参数-XX:+UseAdaptiveSizePolicy打开后，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量————GC自适应的调节策略（GC Ergonomics）。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。</p><h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p>Serial收集器的老年代版本，是单线程收集器，给Client模式下的虚拟机使用。</p><h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法，在注重吞吐量以及CPU资源敏感的场合，用于配合Parallel Scavenge收集器。</p><h2 id="CMS（Concurrent-Mark-Sweep）收集器"><a href="#CMS（Concurrent-Mark-Sweep）收集器" class="headerlink" title="CMS（Concurrent Mark Sweep）收集器"></a>CMS（Concurrent Mark Sweep）收集器</h2><p>以获取最短回收停顿时间为目标的收集器。基于“标志-清理”算法。具有并发收集、低停顿的特点。</p><p>收集过程分为4个步骤：</p><ol><li>初始标记（CMS initial mark）</li><li>并发标记（CMS concurrent mark）</li><li>重新标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ol><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>是面向服务端应用的垃圾收集器。<br>具有以下特点：</p><ul><li>并行与并发</li><li>分代收集</li><li>空间整合</li><li>可预测的停顿</li></ul><p>收集器运行过程大致如下：</p><ol><li>初始标记（Initial Marking）</li><li>并发标记（Concurrent Marking）</li><li>最终标记（Final Marking）</li><li>筛选回收（Live Data Counting and Evacuation）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;垃圾收集器&quot;&gt;&lt;a href=&quot;#垃圾收集器&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集器&quot;&gt;&lt;/a&gt;垃圾收集器&lt;/h1&gt;&lt;p&gt;一张图了解所有垃圾收集器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/TlqSyOl.png&quot; alt&gt;&lt;br&gt;上图中的收集器两两之间有连线的，则说明可以搭配使用。&lt;/p&gt;
&lt;p&gt;由于markdownpad2不知道怎么回事插入的图片无法显示，如果无法正常查看图片，可以移步到我的CSDN地址查看图片：&lt;a href=&quot;https://blog.csdn.net/qq_40995335/article/details/83716798&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_40995335/article/details/83716798&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="Alexaccele.github.io.git/categories/JVM/"/>
    
    
      <category term="JVM" scheme="Alexaccele.github.io.git/tags/JVM/"/>
    
      <category term="垃圾收集器" scheme="Alexaccele.github.io.git/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>防止跨站点请求伪造</title>
    <link href="Alexaccele.github.io.git/2018/10/20/%E9%98%B2%E6%AD%A2%E8%B7%A8%E7%AB%99%E7%82%B9%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
    <id>Alexaccele.github.io.git/2018/10/20/防止跨站点请求伪造/</id>
    <published>2018-10-20T09:38:47.000Z</published>
    <updated>2020-04-16T08:29:12.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>跨站点请求伪造（Cross-Site Request Forgery,CSRF）是一种常见的攻击手段。<br>它的工作原理是在用户使用浏览器安全登录网站后，浏览器会以Cookie的形式保存信息，其中就包含用户的登录信息，然后在不关闭浏览器的情况下，用户可能访问一个危险网站，这个危险网站就能通过获取Cookie信息来仿造用户的请求，进而请求安全网站，并进行一些危险操作从而给网站带来危险。<br><a id="more"></a></p><h2 id="CSRF的常见特性"><a href="#CSRF的常见特性" class="headerlink" title="CSRF的常见特性"></a>CSRF的常见特性</h2><ul><li>依靠用户标识危害网站</li><li>利用网站对用户标识的信任</li><li>欺骗用户的浏览器发送HTTP请求给目标站点</li><li>另外可以通过IMG标签会触发一个GET请求，可以利用它来实现CSRF攻击。</li></ul><h2 id="防止CSRF"><a href="#防止CSRF" class="headerlink" title="防止CSRF"></a>防止CSRF</h2><p>在spring-security中提供了处理CSRF的过滤器，并且在默认情况下，是启用过滤器来防止CSRF攻击的，但在开发过程中，有时CSRF防护可能会影响我们的开发效率，所以这里给出关闭的方法。</p><pre><code>/*安全配置类*/@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true)// 启用方法安全设置public class SecurityConfig extends WebSecurityConfigurerAdapter {    @Override    protected void configure(HttpSecurity http) throws Exception {        http.and().csrf().ignoringAntMatchers(&quot;/h2-console/**&quot;);//禁用H2控制台的CSRF防护,即关闭指定请求的csrf                    //.and().csrf().disable();完全关闭csrf    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CSRF&quot;&gt;&lt;a href=&quot;#CSRF&quot; class=&quot;headerlink&quot; title=&quot;CSRF&quot;&gt;&lt;/a&gt;CSRF&lt;/h2&gt;&lt;p&gt;跨站点请求伪造（Cross-Site Request Forgery,CSRF）是一种常见的攻击手段。&lt;br&gt;它的工作原理是在用户使用浏览器安全登录网站后，浏览器会以Cookie的形式保存信息，其中就包含用户的登录信息，然后在不关闭浏览器的情况下，用户可能访问一个危险网站，这个危险网站就能通过获取Cookie信息来仿造用户的请求，进而请求安全网站，并进行一些危险操作从而给网站带来危险。&lt;br&gt;
    
    </summary>
    
      <category term="CSRF" scheme="Alexaccele.github.io.git/categories/CSRF/"/>
    
    
      <category term="CSRF" scheme="Alexaccele.github.io.git/tags/CSRF/"/>
    
  </entry>
  
</feed>
